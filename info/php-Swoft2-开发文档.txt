^2_3^2workroom3工作室
--
//// 开发文档 (Swoft-v2.x-教程手册)
https://www.swoft.org/documents/index.html
//// 日期时间
2019-12-29
--
--
第一卷 框架概述 SWOFT
https://www.swoft.org/documents/v2/
--
1、SWOFT简述
Swoft 是一款基于 Swoole 扩展实现的 PHP 微服务协程框架。Swoft 能像 Go 一样，内置协程网络服务器及常用的协程客户端且常驻内存，不依赖传统的 PHP-FPM。有类似 Go 语言的协程操作方式，有类似 Spring Cloud 框架灵活的注解、强大的全局依赖注入容器、完善的服务治理、灵活强大的 AOP、标准的 PSR 规范实现等等。
--
2、SWOFT特性
Swoft 通过长达三年的积累和方向的探索，把 Swoft 打造成 PHP 界的 Spring Cloud, 它是 PHP 高性能框架和微服务治理的最佳选择。
内置高性能网络服务器（Http/Websocket/RPC/TCP）；
灵活的组件功能；
强大的注解功能；
多样化的命令终端（控制台）；
强大的面向切面编程（AOP）；
容器管理，依赖注入（DI）；
灵活的事件机制；
基于PSR-7的HTTP消息的实现；
基于PSR-14的事件管理；
基于PSR-15的中间件；
国际化（i18n）支持；
简单有效的参数验证器；
高性能连接池（Mysql/Redis/RPC），自动重新连接；
数据库高度兼容Laravel的使用方式；
Redis高度兼容Laravel的使用方式；
秒级定时任务；
Session 管理；
进程池；
秒级定时任务；
Session 管理；
进程池；
服务注册与发现；
配置中心；
服务限流；
服务降级；
服务熔断；
Apollo；
Consul；
--
3、关于 Swoft
Swoft 是基于 Swoole 的企业级 PHP 应用程序开发框架，大量开发人员使用 Swoft Framework 来创建高性能、易于测试和可重用的代码。
Swoft 开源框架自 2018 年 3 月 6 日发布以来，我们秉承简单、高效、稳定的宗旨持续迭代升级。伴随着 1.x 的开发迭代和 Swoole 4 全协程化，1.x 的底层架构已经不再合适，所以在 2018 年 11 月开始规划 2.x。新版本底层借鉴 1.x 的经验全部重写，采用 Swoole Hook 全协程化，整体相比 1.x 更易上手，稳定性也更高。
Swoft 是一款轻量级的框架，所有组件均可以自定义且支持按需加载使用。
Swoft 框架可用于开发任何 Web 应用程序，构建高性能的 Web 系统、API、中间件、基础服务等。
--
4、优势
//// Swoft Framework 的优点
以组件化方式开发，开发者可以自定义组件并按需加载使用；
良好 Web MVC 设计，它为 Web 开发框架提供了一个很好的选择；
PHP 开发者可快速上手，数据库、缓存的使用均高度兼容 Laravel；
所有组件严格通过单元测试及压力测试；
--
5、社区
Swoft 官方 QQ 群 1：548173319（点击添加）
Swoft 官方 QQ 群 2：778656850（点击添加）
Swoft 社区：https://learnku.com/swoft
--
6、支持
您的支持是对开发组的最大鼓励，您可以通过以下方式来支持我们。
赞助 https://www.swoft.org/donation/
参与贡献 https://www.swoft.org/documents/v2/contribute/sub-questions/
--
--
第二卷 开发指南
--
--
一、版本更新
http://swoft.org/documents/v2/dev-guide/update/
--
1、v2.0.8[WIP]
(1)、修复(Fixed)
修复 ws server 的 message response.finish 兼容 swoole 4.4.12 问题 d724a949；
修复 console 组件中拥有短选项的选项获取值不同步问题 ac41eca；
修复 部分字符串操作不兼容 php 7.4 的问题 b4d0e90；
修复 输入未知命令时，显示http server 命令帮助信息有误 684807e；
修复 去除 process 组件中无效的调试语句 2bc84aa；
打包为phar后不能正确的加载同目录下的 .env 文件问题 8046c15；
(2)、更新(Update)
调整 路由没找到时抛出的异常将会携带错误 code 7e06afa；
(3)、增强(Enhancement)
优化 phar 包构建速度，现在打包时间将会大幅度缩短 1055fff；
优化 console 命令参数和选项的解析绑定，设置的类型的将会格式化为对应的类型 7dc0d58；
--
2、v2.0.7(2019-11-18)
升级提示：Swoole\WebSocket\Server::push 第四个参数 4.4.12 后改为了 int 类型。
(1)、修复(Fixed)
修复 config 注入时，没有找到值也会使用对应类型的默认值覆盖属性，导致属性默认值被覆盖 d84d50a7；
修复 ws server 中使用message调度时，没有过滤空数据，导致多发出一个响应。避免方法swoft-cloud/swoft#1002 d84d50a7；
修复 tcp server 中使用message调度时，没有过滤空数据，导致多发出一个响应。07a01ba1；
修复 独立使用console组件时缺少 swoft/stdlib 库依赖 c569c81a；
修复 ArrayHelper::get 传入key为 integer 时，报参数错误 a44dcad；
修复 console 渲染使用table，有int值时，计算宽度报类型错误 74a835ab；
修复 error 组件中用户无法自定义设置默认的错误处理级别 4c78aeb；
修复 启用和禁用 组件设置 isEnable() 不生效的问题 da8c51e56；
修复 在 cygwin 环境使用 uniqid() 方法必须将第二个参数设置为 true c7f688f；
修复 在 cygwin 环境不能够设置进程title而导致报错 c466f6a；
修复 使用 http response->delCookie() 无法删除浏览器的cookie数据问题 8eb9241；
修复 ws server消息调度时，接收到的ext数据不一定是数组导致报错 ff45b35；
修复 日志文件按时间拆分问题c195413；
修复 日志 JSON 格式小问题a3fc6b9；
修复 rpc 服务提供者 getList 调用两次问题fd03e71；
修复 redis cluster 不支持 auth 参数7a678f；
修复 模型查询 json 类型, 不支持 array 6023a9；
修复 redis multi 操作没有及时是否连接 e5f698；
修复 redis 不支持 expireAt, geoRadius 749241；
修复 crontab 时间戳检测偏差问题 eb08a46；
(2)、更新(Update)
更新 console 在渲染 help信息之前也会发出事件 ConsoleEvent::SHOW_HELP_BEFORE d3f7bc3；
简化和统一 http, ws, tcp, rpc server管理命令逻辑 f202c826；
更新 ws 和 tcp Connection类添加 newFromArray 和 toArray 方法，方便通过第三方存储(redis)时导出信息和恢复连接 a8b0b7c；
优化 server 添加统一的 swoole pipe message 事件处理，在 ws, tcp 中使用swoft事件来处理进程间消息 1c51a8c；
(3)、增强(Enhancement)
现在 tcp 请求支持添加全局或对应的方法中间件，流程和使用跟http中间件类似。仅当使用系统调度时有用 6b593877；
现在 websocket message 请求支持添加全局或对应的方法中间件，流程和使用跟http中间件类似。仅当使用系统调度时有用 9739815；
事件管理允许设置 destroyAfterFire 在每次事件调度后清理事件中携带的数据 50bf43d3；
数据库错误异常新增 code 返回fd306f4；
协程文件操作 writeFile 新增写失败异常08c4244；
RPC 新增参数验证8646fc5；
--
3、v2.0.6(2019-09-21)
(1)、升级提示
通过参数注入接收websocket原始数据时，现在需要加上类型 string。例如： public function echo(string $data)；
ws server 中使用message调度时，没有过滤空数据，导致多发出一个响应。避免方法swoft-cloud/swoft#1002；
(2)、修复(Fixed)
修复 ws server收到消息时，默认使用当前fd作为响应消息的客户端 3a8890cf；
修复 ws server通过swoole server拿到的全部连接里，fd的类型可能不是整型导致报错。0fa79d7；
修复 stdlib SystemHelper 在 windows 10 中会被 Defender 删除 71c2893；
修复 increment/decrement 多拿了一个连接 94c7171；
修复 模型属性 $modelTimestamps 关闭了无效 94c7171；
修复 在初始化前调用了log，导致可能会在启动阶段报context丢失错误 5a27704f；
修复 ws server的握手和open使用同一个顶级协程ID，如果有一个先执行完成，可能会导致后面的出现session丢失 c2cd17a；
修复 after 定时器传递参数 bug 8ed609a；
修复定时任务内存泄漏和日志打印数据丢失问题 aa6bc32；
优化 Http server sgo 处理流程 e60d92e；
修复数据库在事物情况下重连导致数据不一致问题 c2e87f2；
修复 Aop 极端情况返回 0 问题 85bc1b1；
修复 BeanFactory::createBean() 方法创建问题c2e2c89；
修复 RPC 错误数据是字符串问题 3a34658；
修复 redisCluster 初始化问题3a60c06；
修复 DbException 没有抛出 Database 的异常 Code3a60c06；
修复 ModelAttribute 的 getter 和 setter 驼峰判断错误2e2f0f1；
修复 Aggregate 聚合, 返回字符串强行转换 int错误7aa98a6；
修复模型 updateCounters 方法更新之后没有同步实体数据967d6f8；
(3)、更新(Update)
调整 ws server在worker 退出时自动关闭连接，添加开关配置，可以选择是否开启。3a8890c；
ws server 新增事件： MESSAGE_PUSH` OPEN_BEFORE MESSAGE_RECEIVE` e1b0583；
(4)、增强(Enhancement)
新增日志按时间切割 f649df2；
新增日志支持传递额外参数 55d5533；
调整和新增了一些ws server相关事件，方便用户使用 e1b0583；
模型对 Prop 支持 630aad8；
新增连接连接池(mysql/redis/rpc)启动初始化连接功能 a367173；
tcp server 使用长度分包时，支持自定义头部数据打包、解包格式 a6fbe932；
RPC 调用错误信息调整 d9226b1；
新增操作 Database 异常, 打印控制台 错误 SQL3a60c06；
新增操作数据迁移 int 系列 长度支持967d6f8；
新增获取原始 sql 方法getRawSql967d6f8；
扩展updateOrInsert和updateOrCreate 支持自增参数967d6f8；
(5)、扩展(Extra)
swoftcli 支持类生成，创建新的应用、组件结构。使用请查看文档；
swoftTracker 支持方便开发者调试；
--
4、v2.0.5-beta(2019-08-06)
(1)、升级提示
请使用 context() 代替 Context::mustGet()；
这个版本开始验证器默认关闭，需要开发者开启 validator setting；
(2)、修复(Fixed)
修复提前中断请求逻辑可能导致无法正确的格式化对应的Content-Type f031398；
修复使用sgo创建子协程，在结束时没有清理与顶级协程的映射关系 de11ae5b；
修复 Xml 格式解析方法 24d0038；
修复类代理 Unique 字符串问题 444ddeb；
修复 context()->get() 存在问题以及废弃 Context::mustGet() 方法 6acc1b5；
修复接口注入，类名访问错误 2d9a31f；
修复 模型使用 paginate 方法, 结果集没有映射字段3027287；
修复 websocket server 里，当有多个worker，主动关闭非当前worker连接时报错 7666969；
(3)、更新(Update)
默认的 worker num 设置通过 swoole_cpu_num 函数获取 553f6500；
验证器调整成，默认非必须，用户自己开启 e5b258d；
不再抛出swoft内部的 ContainerException 到用户使用层 1e74893；
console output 新增 confirm` select` 等交互方法 0181138a；
(4)、增强(Enhancement)
console 命令选项设置 CommandOption，现在允许选项描述为多行信息 e5914983；
websocket server 的全部消息发送方法，支持传入 opcode 参数 dc164ffe9；
websocket 模块允许设置当前模块的默认 opcode，用于自动处理返回数据设置 opcode 9e3e9672；
增强 websocket 相关类，现在消息处理方法允许注入更多数据对象类型 Request` Response` 3d6c60b4；
当worker退出时，websocket server 会自动关闭所有连接 5ea10ecc；
Add Timer 定时器封装 eb92ee6；
Add Coroutine 方法封装 d8c2b88；
(5)、扩展(Extra)
swoft/crontab 秒级别定时任务；
swoft/whoops 对 filp/whoops 在swoft中使用的简单封装，用于渲染并显示更加利于阅读的错误信息；
--
5、v2.0.4-beta(2019-07-21)
(1)、升级注意
请去掉 bin/swoft 里的 Runtime::enanbleCoroutine() 设置；
请确保 swoole 的 swoole.use_shortname 的值为 On；
从这个版本开始要求 swoole 4.4.1+；
(2)、增强(Enhancement)
Swoft\Http\Message\Request 新增 getHeaderLines() (74a2a91)；
Aop 新增 getArgsMap() 和 getClassName() 方法 (c47e785)；
新增 srun() 函数，用于协程调度 (3c4a6a4)；
优化 server 事件(onStart / onWorkStart / onWorkStop / onShutdown)，事件自带支持协程 (a8d5a8d)；
新增投递同步阻塞任务(ec938e5)；
新增 Redis call 方法, 用于使用同一连接操作(92456987)；
兼容 Swoole 4.4.x；
(3)、修复(Fixed)
修复 迁移类名太长导致记录类名不全(58314b8)；
修复 实体查询之后使用Setter更新字段值之后update更新无效(caadf0e)；
修复 stop 后删除pid文件的结果返回错误，导致restart失败 (2be450bf11)；
修复 i18n 设置默认语言不生效的问题 (b401a504e)；
修复 ws server在有多个worker时，无法主动关闭其他worker的连接(271b6398)；
修复 http server接收xml请求时，content type 不能正确匹配(2ff9a4e61)；
修复 使用 Database, json 操作无效(92456987)；
修复 limiter 限速器 Redis 加前缀无法使用问题(7b54d4c)；
(4)、更新(Update)
更新 ws server 可以通过配置 disabledModules 来禁用 ws 模块(fa31111d)；
(5)、扩展(Extra)
在官网增加案例展示，欢迎大家提交案例到官方案例仓库 swoft-cloud/swoft-case；
在GitHub上对文档的修改，将会自动更新到官网文档，不再需要手动刷新；
(6)、新增(New)
进程管理(c61b8f7)；
自定义用户进程(c328d54)；
进程池(d2e6290)；
TCP server 基本可用；
--
6、v2.0.3-beta(2019-07-08)
(1)、不兼容(Incompatible)
移除 request->json() 方法(c9e8f04) 替代方法 getParserdBody()；
应用日志和控制台日志 levels 由数组配置改成，字符串配置，详细见文档；
(2)、新增(Enhancement)
新增接口依赖注入(6169f84)；
新增 getFile 方法获取文件上传保存之后的信息(fe7e3a6)；
新增 restart() 服务新增重启方法(2ffec37)；
新增调用 1.x RPC 服务支持(30d73c3)；
新增 AOP 类名匹配支持正则表达式(bc5e479)；
新增 RPC Server /Http Server 中间件命名空间 use 错误提示(b1cec04)；
新增 验证器排除属性字段 unfields(b1bf44f)；
新增 自动写入时间戳(dc58011)；
新增 模型动作事件(dc58011)；
新增 数据库迁移(26bb464)；
新增 实体自动与 json 和数组互转(dc58011)；
新增 模型批量更新方法batchUpdateByIds(dc58011)；
(3)、修复(Fixed)
修复 cookies 设置时的一些问题，增加一些 withCookie 相关方法(b05afbb01)；
修复 在console使用协程方式运行命令时，没有捕获处理错误(8a5418bf)；
修复 websocket server 重启命令没有先停止旧server问题(db2d935)；
修复任务返回值为 null 问题(a69347c)；
修复 RPC Server 只有类中间件无法使用问题()204bc7f；
修复 RPC Server 返回值为 null 问题(4d091be)；
修复 Logger 和 CLog 日志等级无法覆盖和无效问题(8eb8aba)；
修复 模型里面的属性不支持自定义表达式(dc58011)；
(4)、更新(Update)
验证器优化，支持自定义验证规则(d959a4f)；
重命名错误处理管理类 ErrorHanlders 为 ErrorManager (f3a8f04b)；
console组件的异常处理改为由error组件提供的统一处理风格 (4f47204)；
console组件允许设置禁用命令组(c5a0269)；
在默认的错误处理中，允许设置错误捕获级别。默认级别是 E_ALL | E_STRICT (afff9029)；
优化 启动ws server时同时启用了http处理功能，信息面板添加提示(83a81170)；
优化 启动ws server 并同时添加rpc server启动，信息面板没有显示 rpc server信息(3d1d0d848)；
(5)、扩展(Extra)
文档添加支持通过google进行搜索；
新增 apollo 组件；
新增 consul 组件；
新增 breaker 组件；
新增 limter 组件；
新增 tcp-server 组件；
--
7、v2.0.2-beta(2019-06-21)
(1)、新增(Enhancement)
新增 $request->parsedQuery() 方法 (ab45089)；
新增 Bean 属性注入基础数据类型(string/int/bool/float/array)，自动根据注释类型转换。(e3d4085)；
新增 db(), 使 Model/Query/DB 支持切库(f3b12c9)；
新增 DbSelectorInterface 用于根据业务自动切库(b36ca03)；
新增 Http server 增加Cookies响应支持 (1a024bf)；
新增 devtool 组件的实体生成(14b4d39c)；
新增 允许注册 swoole 的 pipeMessage, packet 事件[afec0e3f]；
新增 添加更多启动时的相关事件[8aaa38c4]；
新增 validate() 不依赖注解验证方式(cc35560)；
新增 RPC 调用返回错误 RpcResponseException 异常(baa482f)；
新增 允许注册 swoole 的 pipeMessage, packet 事件(afec0e3f)；
新增 添加更多启动时的相关事件(8aaa38c4)；
(2)、修复(Fixed)
修复 paginate 无法指定查询字段(308d330)；
修复 实体 join 操作，显示不出关联表数据 (446a3a2)；
修复 实体属性名attributes等与系统定义属性冲突问题 (1a9d25b)；
修复 AOP 切面重复执行问题 (54e00ac)；
修复 Http 服务全局异常 contentType 失效问题(e704116)；
修复 Http server在启用https 时，type 检查无法通过 (3e9b431)；
修复 Http server通过data响应html时可能出现错误(e5513df)；
修复 控制器 table 数据显示 (4d27718)；
修复 devtool 生成的 phpstorm meta文件key重复(1838552)；
修复 ws-server 参数路由匹配失败(4d3392e6)；
修复 Http 服务 content-type 多值解析错误问题(1657979)；
修复 Co::multi 抛出异常调用错误问题(d0ff0f7)；
修复 body 字符串无解析调用错误问题(32abf60)；
修复 通过 setter操作实体 toArray失效问题(9c0f9505)；
现在停止server(包含Ctrl+C)时总是会删除pid文件，修复没有删除pid文件导致docker重启失败问题(6a96b2c)；
修复 通过 @Inject 注入Redis连接池没有释放以及连接池全部空闲判断问题(feac3700)；
修复 数据库开启事物多连接池操作错误(3f80474)；
修复 init() 方法中使用 config() 函数问题(fe9b92b)；
修复 getParsedQuery() 方法初始化问题(8e05836)；
修复 一些bean会出现重复初始化(例如 config)问题 (f8ef5a9a)；
修复 Autoloader 文件与其它composer包文件冲突问题 (ba19af363)；
(3)、更新(Update)
修改模型方法insert,insertGetId,updateOrInsert只会插入定义了@Column字段(9c0f9505)；
启动swoft时加入冲突扩展相关的运行环境检查(7fa7188f)；
调整 count,sum,avg,max,min 返回值类型(c9b5e17a)；
Http server 路由匹配顺序优化(d8fb588)；
完善 RPC Client 调用错误信息提示(a1e56eb)；
调整 Redis zAdd 成员和分数的位置⚠️不向下兼容(1a3275b3)；
调整 如果没有添加验证注解，会跳过验证解析相关流程(582c806cc)；
去除swoole中已经废弃的 buffer full/empty 事件相关代码 (873a97bed)；
优化 Http server 验证器流程(0e73a8c)；
(4)、扩展(Extra)
swoft/view 添加通过 @View 渲染视图支持；
--
8、v2.0.1-beta (2019-05-29)
(1)、新增(Enhancement)
新增验证器不存在错误提示(5ba8682)；
新增 AOP 代理类名称标识 _PROXY_(5ba8682)；
新增实体字段值类型转错误异常提示(ab3cfea)；
新增 BeanFactory::getBeans() 根据类名查询使用实例(999c10f)；
新增 Model getAttributeValue 获取字段值方法(642d791e)；
新增 Get 方式参数验证(6452a37)；
新增 Redis 通过 Inject 方式注入使用(fc0a88e)；
新增 RRC 服务全局异常处理(1653b24)；
(2)、修复(Fixed)
修复 CLog 日志调用栈错误(868102f)；
修复 Co::multi 调用失败错误数据格式(5ba8682)；
修复 Function.php 重复加载(b063dd1)；
修复 Logger 日志调用栈错误(ab3cfea)；
修复 worker 进程退出未释放(close)数据库、缓存、RPC 连接池(5b1baa5)；
修复 开发者自定义 content-type 失效问题(22cf706)；
修复 request/session 级别销毁失效问题(e0d1493)；
修复 bean 名称包含 . 点号失效问题(dc37c92)；
修复连接池 maxIdleTime 参数无效问题(0e05591)；
修复 文件上传 (10bc7fa)；
修复 默认输出编码为UTF8 (755c8cf)；
优化 Redis 配置类型转换(533b592)；
打包为phar运行时路径错误(533b592)；
(3)、Swoft-cli
修复一些问题 swoft-cli；
发布新版本时自动通过travis部署phar到GitHub release (d1503b2)；
(4)、Devtool
新 bean 方法代码智能提示(bean()`/BeanFactory::getBean()/Swoft::getBean()`)(b63fe07)；
--
9、v2.0.0-beta (2019-05-21)
Swoft 2 重构归来，基于 Swoole hook 方式，底层完全重构，相比之前更佳简单、稳定、易上手。
(1)、功能特性
内置高性能网络服务器(Http/Websocket)；
灵活的组件化；
灵活的注解功能；
多样化命令终端(Console)；
强大的切面编程（AOP）；
完善的容器管理、依赖注入 (DI)；
灵活的事件机制；
基于 PSR-7 的 HTTP 消息实现；
基于 PSR-14 的事件管理器；
基于 PSR-15 的中间件；
可扩展的高性能 RPC；
国际化(i18n)支持；
简单高效的参数验证器；
高性能连接池(Mysql/Redis/RPC)，自带断线重连；
数据库高度兼容 laravel；
缓存 Redis 高度兼容 Laravel；
高效任务处理；
灵活的异常处理；
强大的日志系统；
--
--
二、贡献规范
https://www.swoft.org/documents/v2/dev-guide/contribute-standard/
Swoft 开源框架，非商业项目，由开源组织开发与维护，这意味着任何人都可以为其开发和进步贡献力量。参与 Swoft 有多种方式：代码贡献、文档贡献、官网维护、社区维护。
--
1、代码贡献
Fork 组件代码库 swoft-component ( https://github.com/swoft-cloud/swoft-component )；
发送 Pull Request 修改请求；
等待 Swoft 开发组审核和合并；
所有官方维护的组件均由swoft-component ( https://github.com/swoft-cloud/swoft-component )项目统一合并后分发到各个组件。
--
2、参与 swoft 的开发是否很难
//// 通过对比 swoft 和传统框架, 来回答这个问题
(1)、框架定位
传统框架: 适合开发「巨石应用」, 所有功能都包含在同一份代码库中, 适合初创团队快速实现原型；
swoft: 致力于实现 PHP 下的微服务, 功能都由「组件」提供, 可以按照实际需求按需加载组装；
(2)、开发难度
///1/ 传统框架
熟悉经典的 lnmp 体系, 只用考虑 PHP 语法；
通常需要完整熟悉整个框架, 才可能参与开发, 老旧的框架提 PR 可能很久才会处理；
///2/ swoft
熟悉 swoole 以及网络编程的基础知识, 就能轻松用 PHP 写出并发能力远超 fpm；
开发组提供开发指南, 组件说明, 快速响应, 开发者可以选取一个简单的组件上手, 快速完成一个 PR；
难? 我亦无他，唯手熟尔。
--
3、开发步骤
(1)、使用 docker
推荐使用 docker 解决开发环境的困扰, 开发组维护了 swoft/swoft ( https://www.swoft.org/docs/2.x/zh-CN/introduction/update.html ) 和 swoft/alphp ( https://github.com/swoft-cloud/alphp ) 两个镜像, 简单示例。
//
//// 使用 docker-compose 进行服务编排
version: '3.1'
services: # 定义服务
    swoft: # 服务的名称
        image: swoft/alphp:cli
        volumes:
            - ../:/data # 挂载本地的源码到容器的 /data 目录下
        ports:
            - "80:9501" # 映射本地 80 端口到容器 9501 端口
        links: # 其他基础服务也可以用 docker 解决, 用不到可以先去掉
            - redis
            - mysql
            - rabbitmq       
        tty: true # 开启后, 可以使用 exec 进入到容器中
//
//// 简单使用
docker-compose up -d swoft # 启动服务
docker-compose exec swoft # 进入容器中
(2)、swoft 项目说明
//// swoft 包含2个重要项目
swoft-cloud/swoft-component: ( https://github.com/swoft-cloud/swoft-component ) swoft 源码, 组件都在此项目的 src/ 目录下；
swoft-cloud/swoft: ( https://github.com/swoft-cloud/swoft ) swoft 脚手架, 加载了全部组件并提供了所有组件的使用 demo；
//
//// 换一个说法
参与 swoft，其实在做应用层的事，业务中要怎么写，参考 swoft 中的 demo 就行，通俗说 – 造飞机。
参与 swoft-component，其实是参与其中具体的某个/某几个组件，通俗说 – 造飞机引擎。
//
//// swoft 的架构设计, 体现在 swoft 的组件化实现中
框架组件 framework: 框架核心工作, 以及框架核心配套的组件；
swoft 功能组件: 按照功能进行划分, 依赖框架组件, 可以按需加载, 常见的有rpc 全家桶( rpc rpc-server rpc-client )；cli 引用( console )；
如果只是想 造飞机, 只用给 swoft 项目提 PR 即可; 如果想 造飞机引擎, 需要给 swoft-component 提 PR, 本地还需要一份类似 swoft 项目的脚手架, 用来验证
(3)、举个例子: 参与 RPC 组件开发
如果对 RPC 的基本概念不熟悉, 参考 RPC 组件相关文档。新建一个空文件夹, 比如 swoft-test, 充当 swoft 项目的角色, 作为脚手架, 加载需要的组件。
//
//// 需要的基础文件
➜  swoft-test tree -L 2
.
├── app
│   ├── Application.php
│   └── bean.php
├── bin
│   ├── bootstrap.php
│   └── test.php
├── composer.json
├── config
是的, 只需要这么多, 从 swoft 复制过来即可。
//
//// 使用 composer 加载 swoft 组件
{
  "require": {
    "swoft/rpc": "dev-master",
    "swoft/rpc-server": "dev-master",
    "swoft/rpc-client": "dev-master"
  },
  "autoload": {
    "psr-4": {
      "App\\": "app/"
    },
  },
  "minimum-stability": "dev",
  "repositories": {
    "hyperf": {
      "type": "path",
      "url": "../swoft-component/src/*"
    },
    "packagist": {
      "type": "composer",
      "url": "https://mirrors.aliyun.com/composer/"
    }
  }
}
}
这里涉及 composer 从本地加载依赖文件的用法, 不熟悉可以参考 官方文档 composer-repository ( https://getcomposer.org/doc/04-schema.md#repositories )。
//
//// 好了, 更新
composer u --no-dev
之后就可以执行 php bin/swoft 来进行相应测试了, 如果遇到报错, 根据报错添加缺少的组件即可。
//
//// 修改 RPC 相关文件
修改 swoft-component 下的组件, 建议多和开发组交流, 有开发范式和 CI 来保证组件的开发质量和稳定性。
--
4、需要了解的更多知识
docker 基础知识。
github 如何提 PR. 推荐一个好用的工具, github desktop, 有快捷键快速提 PR。
composer 文档, 组件开发和生产项目有所差异, composer 提供了一些有意思的功能, 方便开发组件。
推荐使用 mac + phpstorm + docker, 构建全套开发环境. 有相关问题, 欢迎和开发组交流。
--
--
三、优质教程
https://www.swoft.org/documents/v2/dev-guide/course/
本章收集 Swoft 优质教程，方便开发者快速学习上手。如果您有好的优质教程，可以联系我们 (Swoft@qq.com)。
--
1、1.x 系列
(1)、视频
//// Sunny系列
// [收费]_Swoft高性能协程框架
http://www.yzmedu.com/course/263
//
//// 老司机系列
// Swoft速学基础篇
http://www.jtthink.com/course/65#1325
// Swoft基础进阶篇
http://www.jtthink.com/course/73
--
2、2.x 系列
(1)、文章
//// Swoft2.x 学习社区
https://learnku.com/swoft
//
//// [收费]_Swoft2.x从入门到微服务
https://www.kancloud.cn/sphynx/swoft
//
//// Swoft2.x 小白系列教程
https://8code.net/index/index/blog/type/back
(2)、视频
//// Sunny 系列
// [收费]_Swoft2.x入门到微服务
https://study.163.com/course/introduction.htm?courseId=1006515006
//
//// [收费]_老司机系列
// Swoft2.x 基础篇
http://www.jtthink.com/course/65
//
// Swoft2.x HTTP API 篇
http://www.jtthink.com/course/87
//
// Swoft2.x 微服务基础篇
http://www.jtthink.com/course/93
//
// swoft2.x 实战第一季
http://www.jtthink.com/course/98
--
--
四、开发注意事项
https://www.swoft.org/documents/v2/dev-guide/dev-note/
--
1、注意事项
(1)、禁止使用$_GET、$_POST、$GLOBALS、$_SERVER、$_FILES、$_COOKIE、$_SESSION、$_REQUEST、$_ENV等超全局变量。
(2)、谨慎使用global、static关键字。
(3)、不要在代码非协程环境中执行sleep以及其他睡眠函数，这样会导致整个进程阻塞，exit/die 是危险的，会导致 worker 进程退出。
(4)、不要在业务代码中使用 swoole 不支持的 hook, 例如 MongoDB`,pgsql client`, 如果需要使用这些扩展需要单独开用户进程执行。
(5)、无法 hook 的 io 都会同步阻塞进程, 导致协程无法切换, 直接的影响就是服务器大规模超时。
(6)、不建议使用 curl 扩展 类似的GuzzleHttp, 推荐使用 swoft 封装的网络请求包。
(7)、Swoole 短名开启 ,在 php.ini 中配置swoole.use_shortname = 'on'。
--
2、常见问题
(1)、The HTTP server have been running!(PID: xx)
出现这种问题，是因为服务已经启动了。通常两种方式解决，第一种方式，stop 服务。第二种方式，kill pid。
(2)、Could not scan for classes inside xxx which does not appear to be a file nor a folder
出现这种问题是composer源的问题，一般会在创建项目`(composer create swoft/swoft swoft)的时候出现，解决办法很简单只需要切换源全局设置即可。如：composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/`。
(3)、代码格式
推荐参照 PSR2 ( https://www.php-fig.org/psr/psr-2/ ) 代码规范。
--
--
五、常见内存溢出
https://www.swoft.org/documents/v2/dev-guide/memory-overflow/
--
1、内存溢出
内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。
内存泄漏通常情况下只能由获得程序源代码的程序员才能分析出来, 也是一个比较难以排查的问题，所以需要在开发前知道一些规范。内存溢出一直向一个 属性/变量 写数据, 写入超过内存最大限额, php 会抛出致命错误可能导致进程退出。要避免内存溢出，首先要知道常驻内存开发，局部变量处理完毕之后会被GC，静态变量/静态属性的值GC不会标记回收，需要用户自己管理。不建议使用 静态变量/静态属性 来共享内存, 因为用户很难管理自己的内存空间。
不同的进程中PHP变量不是共享，即使是全局变量，在A进程内修改了它的值，在B进程内是无效的，如果需要在不同的Worker进程内共享数据，可以用Redis、MySQL等工具实现Worker进程内共享数据。
(1)、为什么Config Bean不支持动态写入？
下面是 Config Bean 部分源码，你可能好奇，写入为啥会抛异常呢？下面我们就来分析这个吧！
//
<?php declare(strict_types=1);

namespace Swoft\Config;

use InvalidArgumentException;
use Swoft\Bean\Annotation\Mapping\Bean;
use Swoft\Config\Contract\ParserInterface;
use Swoft\Config\Exception\ConfigException;
use Swoft\Config\Parser\PhpParser;
use Swoft\Config\Parser\YamlParser;
use Swoft\Stdlib\Collection;
use Swoft\Stdlib\Helper\ArrayHelper;

/**
 * Class Config
 *
 * @Bean("config")
 *
 * @since 2.0
 */
class Config
{
    /**
     * The items contained in the collection.
     *
     * @var array
     */
    protected $items = [];

    // ......

    /**
     * Get value
     *
     * @param mixed $key
     *
     * @return mixed
     */
    public function offsetGet($key)
    {
        return ArrayHelper::get($this->items, $key);
    }

    /**
     * @param mixed $key
     * @param mixed $value
     *
     * @throws ConfigException
     */
    public function offsetSet($key, $value): void
    {
        throw new ConfigException('Config is not supported offsetSet!');
    }

    /**
     * @param string $key
     *
     * @throws ConfigException
     */
    public function offsetUnset($key): void
    {
        throw new ConfigException('Config is not supported offsetUnset!');
    }

    /**
     * @param array|string $keys
     *
     * @return Collection
     * @throws ConfigException
     */
    public function forget($keys): Collection
    {
        throw new ConfigException('Config is not supported forget!');
    }

    // ......
}
?>
//
在 Config 中有一个 item 属性，虽然他不是静态的。但是我们需要明白 单例的 Bean 是全局的生命周期 在创建启动时已经创建创建好了。如果 Config 支持了写入，可能因为某段代码修改了配置导致脏读，请求写入的配置是不会被垃圾回收。
//
//// 所以我们需要明白 Swoft Bean 的生命周期。下面是一张简单的 生命周期 Bean。
php bin/swoft
singleton bean
------------------------------request
                                |
request bean                    |
                                |
------------------------------response
singleton bean
------------------------------
singleton bean 是全局存在的, 所以 singleton 类型的 bean 值是不允许动态修改的。需要借助属性来存储 结果值 请使用 request/prototype 类型的 bean，详情参考 Bean 章节。
(2)、非常驻内存框架常用代码
<?php declare(strict_types=1);

namespace App\Model\Logic;

use App\Model\Data\UserData;
use Swoft\Bean\Annotation\Mapping\Inject;

class UserLogic
{

    /**
     * @Inject()
     *
     * @var UserData
     */
    private $userData;

    /**
     * @var array 
     */
    private static $userCache = [];

    /**
     * @var string
     */
    public static $lastError = '';


    /**
     * Get user list
     *
     * @param array $userIds
     *
     * @return array
     */
    public function getUsers(array $userIds): array
    {
        $users = [];
        foreach ($userIds as $k => $userId) {
            if (isset(self::$userCache[$userId])) {
                $users[] = self::$userCache[$userId];

                unset($userIds[$k]);
            }
        }

        if ( empty( $userIds ) ) {
            return $users;
        }

        $list = $this->userData->getList($userIds);

        if (empty($list)) {
            self::$lastError = 'get user fail';

            return [];
        }

        foreach ($list as $user) {
            $userId = $user['uid'];

            self::$userCache[$userId] = $user;

            $users[] = self::$userCache[$userId];
        }

        return $users;
    }
}
?>
//
//// 上面代码有以下两个问题
使用 $userCache 静态属性来存储查询结果集，在同一进程下的请求数据是共享的，多个请求都写入当超过内存限额就会导致进程退出，也就是内存泄露。
使用 $lastError 静态属性来，存储上一次错误信息，在同一进程下的请求数据是共享的可能会导致数据错乱，这也就是swoft 没有类似 get_last_sql() 这样的函数。
//
说明：由于基于 php-fpm 的多进程模式开发,每个请求的数据是独立的, 使用静态变量共享本次请求数据也是常用的方法。但是在常驻内存下开发，请不要使用 静态属性/全局变量/静态变量 来共享数据，因为swoft 是基于 协程模式，一个进程下面的协程的数据都是共享。并发修改静态属性的情况就会导致数据错乱，使用 static，global 关键字定义变量也是同理，请谨慎使用。
--
--
第三卷、快速开始
--
一、框架安装
https://www.swoft.org/documents/v2/quick-start/install/
--
1、系统要求
Swoft 框架支持 Linux、macOS 以及 Windows 10 (通过 Windows 10 安装 WSL(Windows Subsystem for Linux，windows下的Linux子系统) 后可以使用大部分 Linux 功能，推荐安装 Ubuntu LTS 作为子系统)。
--
2、环境要求
(1)、必要部分
PHP，版本 >=7.1
PHP 包管理器 Composer
PCRE 库
PHP 扩展 Swoole，版本 >=4.3
额外扩展：PDO、Redis
(2)、冲突部分
下方列出部分已知与 Swoole 存在冲突的 PHP 扩展，请在使用 Swoft 时移除安装或禁用：Xdebug、Xhprof、Blackfire、Zend、trace、Uopz。
--
3、安装方式
(1)、通过 Docker 安装
docker run -p 18306:18306 --name swoft swoft/swoft
(2)、通过 Docker Compose 安装
git clone https://github.com/swoft-cloud/swoft
cd swoft
docker-compose up
(3)、通过 Composer 安装
composer create-project swoft/swoft Swoft
提示：建议全局配置 Composer 国内镜像以加速下载、更新包，参考：阿里云 Composer 全量镜像( https://developer.aliyun.com/composer )。
(4)、手动安装
git clone https://github.com/swoft-cloud/swoft
cd swoft
composer install
cp .env.example .env
# 编辑 .env 文件，根据需要调整相关环境配置
(5)、通过 Swoft CLI 创建
关于 Swoft CLI 工具，请查阅 Swoft CLI 文档( https://www.swoft.org/documents/v2/dev-tools/swoft-cli )，该工具支持从不同模板项目中快速创建一个干净的 Swoft 应用。
php swoftcli.phar create:app --type full Swoft-Full
php swoftcli.phar create:app --type ws Swoft-WebSocket
php swoftcli.phar create:app --type tcp Swoft-TCP
--
4、IDE 插件
通过文本编辑器进行 Swoft 开发时，Swoft 的注解功能虽然便捷，但仍需要 use 注解相对应的命名空间，这显然不是一个高效的做法。我们推荐在使用集成开发环境 IDEA 或 PhpStorm 时，通过插件市场搜索并安装 PHP Annotations 插件以提供注解命名空间自动补全、注解属性代码提醒、注解类跳转等非常有助于提升开发效率的功能。
--
--
二、目录结构
https://www.swoft.org/documents/v2/quick-start/directory-struct/
--
1、简介
//// 一个完整的 Swoft 应用包含
Console 应用；
HTTP 服务（类似传统框架）；
WebSocket 服务；
RPC 服务；
TCP 服务；
说明：app 下的类目录为了避免部分文件夹名称没有复数单词而导致命名不统一，所以所有文件夹名称 统一使用单数。
--
2、完整结构
├── app/    ----- 应用代码目录
│   ├── Annotation/        ----- 定义注解相关
│   ├── Aspect/            ----- AOP 切面
│   ├── Common/            ----- 一些具有独立功能的 class bean
│   ├── Console/           ----- 命令行代码目录
│   ├── Exception/         ----- 定义异常类目录
│   │   └── Handler/           ----- 定义异常处理类目录
│   ├── Http/              ----- HTTP 服务代码目录
│   │   ├── Controller/
│   │   └── Middleware/
│   ├── Helper/            ----- 助手函数
│   ├── Listener/          ----- 事件监听器目录
│   ├── Model/             ----- 模型、逻辑等代码目录(这些层并不限定，根据需要使用)
│   │   ├── Dao/
│   │   ├── Data/
│   │   ├── Logic/
│   │   └── Entity/
│   ├── Rpc/               ----- RPC 服务代码目录
│   │   └── Service/
│   │   └── Middleware/
│   ├── WebSocket/         ----- WebSocket 服务代码目录
│   │   ├── Chat/
│   │   ├── Middleware/
│   │   └── ChatModule.php
│   ├── Tcp/               ----- TCP 服务代码目录
│   │   └── Controller/        ----- TCP 服务处理控制器目录
│   ├── Application.php    ----- 应用类文件继承自swoft核心
│   ├── AutoLoader.php     ----- 项目扫描等信息(应用本身也算是一个组件)
│   └── bean.php
├── bin/
│   ├── bootstrap.php
│   └── swoft              ----- Swoft 入口文件
├── config/                ----- 应用配置目录
│   ├── base.php               ----- 基础配置
│   └── db.php                 ----- 数据库配置
├── public/                ----- 公共目录
├── resource/              ----- 应用资源目录
│   ├── language/              ----- 语言资源目录  
│   └── view/                  ----- 视图资源目录  
├── runtime/               ----- 临时文件目录（日志、上传文件、文件缓存等）
├── test/                  ----- 单元测试目录
│   └── bootstrap.php
├── composer.json
├── phar.build.inc
└── phpunit.xml.dist
--
--
三、运行服务
https://www.swoft.org/documents/v2/quick-start/run-server/
--
1、简述
Swoft 拥有便捷的命令行工具和相应的服务管理命令，参阅 Swoft Devtool( https://www.swoft.org/documents/v2/dev-tools/swoft-devtool ) 了解更多。
--
2、HTTP 服务
# 启动 HTTP 服务
$ php ./bin/swoft http:start
#
# 以守护进程模式启动
$ php ./bin/swoft http:start -d
#
# 重启 HTTP 服务
$ php ./bin/swoft http:restart
#
# 重新加载 HTTP 服务
$ php ./bin/swoft http:reload
#
# 停止 HTTP 服务
$ php ./bin/swoft http:stop
--
3、WebSocket 服务
# 启动 WS 服务
$ php ./bin/swoft ws:start
#
# 以守护进程模式启动
$ php ./bin/swoft ws:start -d
#
# 重启 WS 服务
$ php ./bin/swoft ws:restart
#
# 重新加载 WS 服务
$ php ./bin/swoft ws:reload
#
# 关闭 WS 服务
$ php ./bin/swoft ws:stop
--
4、RPC 服务
# 启动 RPC 服务
$ php ./bin/swoft rpc:start
#
# 以守护进程模式启动
$ php ./bin/swoft rpc:start -d
#
# 重启 RPC 服务
$ php ./bin/swoft rpc:restart
#
# 重新加载 RPC 服务
$ php ./bin/swoft rpc:reload
#
# 关闭 RPC 服务
$ php ./bin/swoft rpc:stop
--
5、启动信息
默认情况下，在任何服务启动时控制台会显示相应的启动信息。如果在 .env 文件中开启了调试 SWOFT_DEBUG=1 将会在控制台中显示更多详细的信息。
//
//// 如果需要关闭这些信息，只需要编辑 app/Application.php 文件
public function getCLoggerConfig(): array
{
    $config = parent::getCLoggerConfig();

    // False: 关闭控制台日志打印
    $config['enable'] = true;

    // 日志等级
    $config['levels'] = 'error,warning';

    return $config;
}
编辑后重启 Swoft 相关服务生效。
--
--
第四卷 开发工具
--
一、PhpStorm
https://www.swoft.org/documents/v2/dev-tools/phpstorm/
--
1、Annotations 插件
通过文本编辑器的环境进行 Swoft 开发，在使用 Swoft 便捷的注解时，仍需要 use 注解相对应的命名空间， 这显然不是一个高效的做法。我们推荐在 PHPStorm 环境下，并安装 Jetbrain 自带的 PHP Annotations 插件，可提供注解命名空间自动补全，注解属性代码提醒，注解类跳转等非常有助于提升开发效率的功能。
--
--
二、Swoft CLI
https://www.swoft.org/documents/v2/dev-tools/swoft-cli/
--
1、简介
GitHub: https://github.com/swoft-cloud/swoft-cli
Swoft CLI 是一个独立的命令行应用，提供了一些内置的功能方便开发者使用：生成 Swoft 应用类文件，例如 HTTP 控制器，WebSocket 模块类等；监视用户 Swoft 项目的文件更改并自动重新启动服务器；快速创建新应用或组件；将一个 Swoft 应用打包成 Phar 包。
欢迎提供意见、贡献代码，Swoft CLI 是基于 Swoft 2.0 框架构建的应用，运行时同样需要安装 Swoole。
--
2、运行预览
$ php swoftcli.phar -h
🛠️ Command line tool application for quick use swoft (Version:  0.1.3)
Usage:
  swoftcli.phar COMMAND [arg0 arg1 arg2 ...] [--opt -v -h ...]
Options:
      --debug      Setting the application runtime debug level(0 - 4)
      --no-color   Disable color/ANSI for message output
  -h, --help       Display this help message
  -V, --version    Show application version information
      --expand     Expand sub-commands for all command groups
Available Commands:
  client         Provide some commands for quick connect tcp, ws server
  gen            Generate some common application template classes(alias: generate)
  new            Provide some commads for quick create new application or component(alias: create)
  phar           There are some command for help package application
  self-update    Update the swoft-cli to latest version from github(alias: selfupdate, update-self, updateself)
  serve          Provide some commands for manage and watch swoft server project
  system         Provide some system information commands[WIP](alias: sys)
  tool           Some internal tool commands, like ab, update-self

More command information, please use: swoftcli.phar COMMAND -h
--
3、安装
安装 Swoft CLI 非常简单，我们已经提供打包好的 Phar 放在 GitHub 上，只需从 Swoft CLI Releases - GitHub ( https://github.com/swoft-cloud/swoft-cli/releases ) 下载打包好的 swoftcli.phar 文件即可。当然你也可以通过 wget 命令下载。
//
//// 通过 wget 命令下载
wget https://github.com/swoft-cloud/swoft-cli/releases/download/{VERSION}/swoftcli.phar
wget https://github.com/swoft-cloud/swoft-cli/releases/download/v0.1.5/swoftcli.phar
注意：你需要替换 {VERSION} 部分为最新版本。
//
//// 检查包是否可用，打印版本信息
php swoftcli.phar -V
//
//// 显示帮助信息
php swoftcli.phar -h
--
4、全局使用
mv swoftcli.phar /usr/local/bin/swoftcli && chmod a+x /usr/local/bin/swoftcli
# 完成后检查是否可用
swoftcli -V
--
5、手动构建
//// 如果你需要通过最新的 Swoft CLI 或修改后的代码构建 Phar 包
// 克隆项目
git clone https://github.com/swoft-cloud/swoft-cli
cd swoft-cli
composer install
// 构建
php -d phar.readonly=0 ./bin/swoftcli phar:pack -o=swoftcli.phar
--
--
三、Swoft Devtool
https://www.swoft.org/documents/v2/dev-tools/swoft-devtool/
--
1、介绍
GitHub: https://github.com/swoft-cloud/swoft-devtool
Swoft 提供了一套内置的命令工具以方便开发者使用。
--
2、安装
//// 默认情况下开发工具已包含在 Swoft 框架中，如需重新安装只需执行下方命令
composer require swoft/devtool
--
3、帮助命令
命令行中所有项均可以通过加上 -h 参数显示更多可选参数提示，例如 php ./bin/swoft http:start -h。
$ php ./bin/swoft -h
Console application description (Version: 2.0.0)
Usage:
  ./bin/swoft COMMAND [arg0 arg1 arg2 ...] [--opt -v -h ...]
Options:
      --debug      Setting the application runtime debug level(0 - 4)
      --no-color   Disable color/ANSI for message output
  -h, --help       Display this help message
  -V, --version    Show application version information
      --expand     Expand sub-commands for all command groups
Available Commands:
  agent      This is an agent for Apllo config center
  app        There are some help command for application[by devtool]
  dclient    Provide some simple tcp, ws client for develop or testing[by devtool]
  demo       Class DemoCommand
  dinfo      There are some commands for application dev[by devtool]
  entity     Generate entity class by database table names[by devtool]
  http       Provide some commands to manage the swoft HTTP server(alias: httpsrv)
  issue      There are some commands for application dev[by devtool]
  migrate    Manage swoft project database migration commands[by devtool](alias: mig)
  process    Provides some command for manage process pool
  rpc        Provide some commands to manage swoft RPC server
  tcp        Provide some commands to manage swoft TCP server(alias: tcpsrv)
  test       Class TestCommand
  ws         Provide some commands to manage swoft websocket server(alias: wsserver,websocket
More command information, please use: ./bin/swoft COMMAND -h
--
4、更多功能
后续会根据用户需要增加更多功能，欢迎用户提供意见、贡献代码。
--
--
第五卷 基础组件
--
--
一、注解
https://www.swoft.org/documents/v2/basic-components/annotation/
--
1、概念介绍
注解（Annotation）又称标注，Java 最早在 2004 年的 JDK 5 中引入的一种注释机制。目前 PHP 官方版本并未提供内置元注解和注解概念，但我们通过 ReflectionClass 反射类解析 PHP 代码注释从而实现了自己的一套注解机制。
--
2、如何使用
就像我们日常开发写注释一样，只需在类、方法或成员变量上方按规则添加注释即可。
//
//// 如定义一个控制器及其路由
use Swoft\Http\Message\Request;
use Swoft\Http\Server\Annotation\Mapping\Controller;
use Swoft\Http\Server\Annotation\Mapping\RequestMapping;
/**
 * Class Home
 *
 * @Controller(prefix="home")
 */
class Home
{
    /**
     * 该方法路由地址为 /home/index
     *
     * @RequestMapping(route="/index", method="post")
     *
     * @param Request $request
     */
    public function index(Request $request)
    {
        // TODO:
    }
}
//
注意需引入相关注解（Annotation）类，且必须以 /** 开始并以 */ 结束，否则会导致无法解析！
--
3、开发规范
//// Swoft 框架注解规范如下
类注解：所有类注释后面；
属性注解：属性描述之后，其它注释之前；
方法注解：方法描述之后，其它注释之前；
请 严格 按照规范使用注解，避免产生错误。如有更佳方式，欢迎提供建议。
--
4、开发工具
参阅：快速开始 - 框架安装 - IDE 插件 ( https://www.swoft.org/documents/v2/quick-start/install/#ide-%E6%8F%92%E4%BB%B6 ) 在 IDEA 或 PhpStorm 中安装 PHP Annotation 插件以提供开发帮助。
--
--
二、容器
https://www.swoft.org/documents/v2/basic-components/container/
--
1、简介
Swoft 基于 PSR-11 规范设计了自己容器，并基于 注解 增强了它的功能。容器是 Swoft 最重要的设计，称得上是 Swoft 的核心精髓，也是 Swoft 各模块的实现基础。本章节将会对容器的相关基础知识做一个介绍，以便大家更好的理解容器。
--
2、前置知识 - IoC
IoC 即控制反转（Inversion of Control），它不是一门技术而是一种设计思想。利用 IoC 将你设计好的对象交给容器控制，而非传统地在你的对象内直接控制、处理。简单来说就是如此，理论知识总是如此，我们继续下文。
--
3、前置知识 - DI
DI 为依赖注入（Dependency Injection）的缩写，DI 其实也不是一门技术，它是一种实现 IoC 的方式。同样的，我们先初步认识 IoC 和 DI 的概念，然后继续阅读下方图文深入理解。
--
4、概念知识
我们知道一台标准的电脑拥有 USB 接口，通过 USB 接口可以扩展电脑功能，如：键盘、鼠标、U 盘、蓝牙、无线网卡等等。只要是拥有标准 USB 接口的设备，连接到电脑上就能使用。现在我们有一台没有 USB 接口的电脑，我们也拥有键盘、鼠标和 U 盘（均为标准 USB 接口设备），当我们需要使用键鼠、U 盘的功能时，就必须 依赖 USB 接口来实现我们的目标。
( 图 https://www.swoft.org/img/computer.png )
电脑 --USB-A--> 键盘/鼠标/U盘
说明：这里的 USB 接口指传统 USB 接口，即 USB-A 接口。
--
5、理解 IoC 与 DI
让我们继续，我们通过一些伪代码来理解上述的 IoC 及 DI。
//
///1/ 定义电脑
class Computer
{
    /** @var 电脑型号 */
    private $model;
    
    /** @var 永不断电！ */
    private $powerOn = true;
    
    public function __construct($model)
    {
        $this->model = $model;
    }
    
    public function useKeyboard()
    {
        // 使用键盘（写代码 yes~）
    }
    
    public function useMouse()
    {
        // 使用鼠标
    }
    
    public function useUDisk()
    {
        // 使用 U 盘
    }
}
//
///2/ USB接口定义
前文提到，我们现在没有 USB，所以我们得依赖 USB 接口实现键鼠、U 盘的使用。
class USBAHub
{
    public function writeCode($computer_model)
    {
      // 果真写代码！
        echo "电脑 {$computer_model} 已开机，我正在疯狂写代码<br>";
    }
    
    public function paintWithMouse($computer_model)
    {
        // 鼠标画图
        echo "电脑 {$computer_model} 已开机，我正在构建灵感美学<br>";
    }
    
    public function storageWithUDisk($computer_model)
    {
        // U 盘存储
        echo "电脑 {$computer_model} 已开机，我用 U 盘存了...（不可描述）<br>";
    }
}
//
///3/ USB接口实现
自从有了这个强大的 USB-A Hub 后，我们就能愉快的使用了。
class Computer
{
    private $model;
    
    private $powerOn = true;
    
    public function __construct($model)
    {
        $this->model = $model;
    }
    
    public function useKeyboard()
    {
        // 使用键盘写代码
        (new USBAHub)->writeCode($this->$model);
    }
    
    public function useMouse()
    {
        // 使用鼠标画图
        (new USBAHub)->paintWithMouse($this->$model);
    }
    
    public function useUDisk()
    {
        // 使用 U 盘存储
        (new USBAHub)->storageWithUDisk($this->$model);
    }
}
//
///4/ 当我们使用这台携带 USB 接口的电脑一天后
$computer = new Computer('神机 i999 + GXX9080Tx');
$computer->useKeyboard();
$computer->useMouse();
$computer->useUDisk();
//
/// 输出内容
电脑 神机 i999 + GXX9080Tx 已开机，我正在疯狂写代码
电脑 神机 i999 + GXX9080Tx 已开机，我正在构建灵感美学~
电脑 神机 i999 + GXX9080Tx 已开机，我用 U 盘存了...（不可描述）
//
可是即便是当年强大的神机也会面临岁月的折磨，我们的 USB 接口在某天变得老化，速度颇慢，跟不上时代的步伐，更不兼容最新的 Type-C 接口，于是我们准备更换到新一代的 USB-C（Type-C）。
( 图 https://www.swoft.org/img/upgrade.png )
电脑 --(旧)USB-A--> 键盘/鼠标/U盘
电脑 --(新)USB-C--> 键盘/鼠标/U盘
但是，USB 接口的更换等同于更换主板（忽略处理器、内存等接口版本差异），拆机、装机、插跳线、配置 BIOS 等工作极其麻烦，我们是否可以将这个工作交给 别人 来完成，从而我们当一个电脑的使用者就好？将这个复杂的工作、控制权交给所谓的“别人”替我们完成的思想就叫做 控制反转。
这个“别人”可以是电脑商贩，也可以是维修店或者朋友，我们现在将“别人”称之为“帮手”。我们将这项工作移交给 帮手 来完成，交给帮手完成的操作实现就是 依赖注入。有了帮手之后，我们通过 构造函数 将帮手 注入 到电脑中，就能轻松使用 USB 设备了。
//
///5/ 控制反转，依赖注入
use Components\Helper;
class Computer
{
    private $model;
    
    private $powerOn = true;
    
    private $helper;
    
    public function __construct($model, Helper $helper)
    {
        $this->model = $model;
        $this->helper = $helper;
    }
    
    public function useKeyboard()
    {
        // 使用键盘写代码
        $this->helper->writeCode($this->$model);
    }
    
    public function useMouse()
    {
        // 使用鼠标画图
        $this->helper->paintWithMouse($this->$model);
    }
    
    public function useUDisk()
    {
        // 使用 U 盘存储
        $this->helper->storageWithUDisk($this->$model);
    }
}
注入的方式有三种，分别是：基于构造函数、基于 setter 方法、基于接口。其中基于构造函数是最常见的注入方式。
//
///6/ 多版本使用
现在我们手中除了旧的 USB-A 的键鼠、U 盘外，也新购置了 USB-C 的键鼠、U 盘，所以我们在使用这台电脑时并不关心 USB 版本。
// 实例化 USB-A
$usbHub = new USBAHub();
// 如果 USB-A 老化，更新使用 USB-C
if($usbHub->isOld()) {
    $usbHub = new USBCHub();
}
// 使用 USB
$computer = new Computer('超级神机 i999 + XXX9080Ti', $usbHub);
为什么不用 USB-B 呢？USB -B 目前我们见得最多的是在打印机上，而 USB-B 和 USB-A 同样是单面插口，而 USB-C（Type-C）是双面插口（不区分正反面）。所以 USB-C 是更为合理的升级方案。
--
6、接口约束
前文我们通过电脑 USB 的例子理解了 IoC 和 DI，但缺少实际开发中最重要的一环——利用接口进行约束。我们应当通过接口类约束 USB-A 以及 USB-C 需要实现的功能，前文中的 帮手 即为接口。
//
///1/ 接口定义
interface HelperInterface()
{
    public function writeCode(string $model);
    
    public function paintWithMouse(string $model);
    
    public function storageWithUDisk(string $model);
    
    public function isOld(): bool;
}
//
///2/ 接口实现
而无论 USB-A 还是 USB-C 均需要实现该接口，以下用 USB-C 举例。
use Components\Interfaces\HelperInterface;
class USBCHub implements HelperInterface
{
    public function writeCode($computer_model)
    {
      // 键盘写代码
        echo "电脑 {$computer_model} 已开机，我正在疯狂写代码<br>";
    }
    
    public function paintWithMouse($computer_model)
    {
        // 鼠标画图
        echo "电脑 {$computer_model} 已开机，我正在构建灵感美学<br>";
    }
    
    public function storageWithUDisk($computer_model)
    {
        // U 盘存储
        echo "电脑 {$computer_model} 已开机，我用 U 盘存了...（不可描述）<br>";
    }
    
    /**
     * 是否老化
     */
    public function isOld()
    {
        return false;
    }
}
USB-C 也将在某天老化，那时可能会有 USB-D、USB-E、USB-F 存在，届时我们仅需根据 HelperInterface 实现相应的 USB-D、USB-E、USB-F 类，并将 USB-C 中 isOld 方法返回 true 即可实现更新，从而平滑过渡到新版本 USB 接口。
--
7、IoC 容器
我们通过前文充分了解了如何利用 DI 实现 IoC，而实际项目中我们可能会面临几十上百个类去处理依赖关系，且类之间还会存在嵌套等问题，那么我们手动实现 IoC 就变得非常困难，效率也低。IoC 容器的出现极其便捷的替我们解决了这一烦恼。
(1)、IoC 容器的主要功能
自动管理依赖关系，避免手工管理存在缺陷。
需要使用依赖时自动注入所需依赖。
管理对象生命周期。
为了更好理解 IoC 容器，我们通过一个简单的示例演示：（代码仅作演示用，Swoft 已提供完善强大且易用的 IoC 容器）。
--
--
三、AOP
https://www.swoft.org/documents/v2/basic-components/aop/
--
1、概念介绍
AOP（Aspect-oriented programming）即 面向切面的程序设计，AOP 和 OOP（Object-oriented programming）面向对象程序设计一样都是一种程序设计思想，AOP 只是 OOP 的补充和延伸，可以更方便的对业务代码进行解耦，从而提高代码质量和增加代码的可重用性。后面的篇章会结合实际案例，教会大家理解并学会使用 AOP。AOP 并不规定必须使用某种方式来实现。
--
2、场景
我们就日志记录功能入手带领大家理解 AOP 切面编程的优势。首先假设我们有以下需求：需要对某个接口做调用记录，记录接口的调用详情（调用参数，返回结果等）；当调用接口出现异常时，做特殊处理，比如记录异常日志、邮件通知运维小伙伴。
如上，我们定义了一个简单的需求，接下来我们去实现它，我们先不要考虑 AOP ，就先用你所熟悉的 OOP 思想来完成以上的需求。
(1)、传统 OOP 实现
///1/ 订单服务类
<?php declare(strict_types=1);
/**
 * 订单服务
 */
class OrderService
{
    /**
     * 生成订单
     *
     * @param string $product_name 商品名字
     * @param int    $quantity     购买数量
     * @param int    $user_id      用户 ID
     *
     * @return array
     */
    public function generateOrder($product_name, $quantity, $user_id): array
    {
        $price = 1000;
        $amount = $price * $quantity;
        $order = [
            'order_no'     => uniqid($user_id . time() . $amount), // 订单号
            'product_name' => $product_name,                       // 商品名称
            'price'        => $price,                              // 商品单价
            'quantity'     => $quantity,                           // 商品数量
            'amount'       => $amount                              // 订单总额
        ];
        return $order;
    }
}
?>
//
///2/ 添加调用日志
在传统的 OOP 思想下，我们要实现所需的功能，可以创建一个类继承 OrderService，然后重写 generateOrder 方法，最后在所有使用 OrderService 的地方替换成新建的类。示例。
<?php declare(strict_types=1);

/**
 * Class InheritOrderService
 *
 */
class InheritOrderService extends OrderService
{
    /**
     * @param string $product_name
     * @param int    $quantity
     * @param int    $user_id
     *
     * @return array
     * @throws Exception
     */
    public function generateOrder($product_name, $quantity, $user_id): array
    {
        // TODO: 记录接口调用参数
        try {
            $result = parent::generateOrder($product_name, $quantity, $user_id);
            // TODO: 处理父方法返回结果，根据返回结果进行相关处理
            return $result;
        } catch (Exception $e) {
            // TODO: 如有异常，记录异常日志并发送邮件，然后继续将异常抛出
            throw $e;
        }
    }
}
?>
//
///3/ 修改调用
最后在我们调用 OrderService 的地方，将 OrderService 替换为 InheritOrderService。
<?php declare(strict_types=1);
  // $order = new OrderService(); // 注释掉旧业务调用
  $order = new InheritOrderService();// 替换
  $order->generateOrder('MacBook Pro', 1, 10000);
?>
//
至此，经过上方的调整后，满足了我们的业务需求。现在我们回顾一下，过程似乎非常繁琐，耦合严重，甚至污染了 generateOrder 方法。如果项目中存在 100 处 OrderService 类的调用，我们就得找到这 100 个地方进行修改、替换，这就是 OOP 的思想。
这时你或许会想到使用中间件、拦截器等类似的方法来解决，其实这些方法本质上也是基于 AOP 的设计思想而来的。前文已经提到，AOP 是基于 OOP 的补充和延伸。
(2)、AOP 实现
AOP 的主要作用是在不侵入原有代码的情况下添加新的功能。我们知道 OOP 实际上就是对我们的功能属性、方法做一个抽象封装，能够清晰的划分逻辑单元。但是 OOP 只能够进行纵向的抽象封装，无法很好的解决 横向 的重复代码，而 AOP 则很好的解决了这一问题。
( 请看图示 https://www.swoft.org/img/OOP.png )
订单类 --> 检查权限 --> 记录日志 --> 相关订单操作 --> 结束
用户类 --> 检查权限 --> 记录日志 --> 相关用户操作 --> 结束
如上图所示，我们有两个类：订单类 和 用户类，我们对其相关功能做了封装。但是，权限检查、日志记录等功能就是在重复的编码，而利用 AOP 思想就可以将这些功能 横向切 出去，然后在适当的时候再将这些功能织入进来。
( 请看图示 https://www.swoft.org/img/AOP.png )
订单类 --(切出/织入)检查权限--> 相关订单操作 --(切出/织入)记录日志--> 结束
用户类 --(切出/织入)检查权限--> 相关用户操作 --(切出/织入)记录日志--> 结束
这就是 AOP。
--
3、相关术语
(1)、Advice（通知）
通知是织入到目标类连接点上的一段代码，例如上方的权限检查及记录日志。
(2)、Aspect（切面）
切面由通知和切点组成，通知明确了目的，而切点明确目的地。
(3)、Introduction（引介）
引介指向一个现有类增加方法或字段属性。引介还可以在不改变现有类代码的情况下实现新的接口。
(4)、Joinpoint（连接点）
程序执行的某个特定位置，将通知放置的地方。如方法调用前、方法调用后、返回、抛出异常等。允许使用通知的地方都可称为连接点。
(5)、Pointcut（切点）
切点指需织入目标的方法。假设一个目标对象（类）中拥有 10 个方法，需要在其中 3 个方法中织入通知，这 3 个方法称为切点。
(6)、Proxy（代理）
应用通知的对象，详细内容参见设计模式里面的代理模式。代理实现了切面的业务， Swoft 使用了 PHP-Parser 库实现 AOP。
(7)、Target（目标对象）
被通知的对象类。目标含有真正的业务逻辑，可被无感知的织入。
(8)、Weaving（织入）
将切面应用至目标对象以创建新代理对象的过程。
--
4、运用声明
(1)、声明切面
//// 通过注解 @Aspect 将类定义为切面类
<?php declare(strict_types=1);
use Swoft\Aop\Annotation\Mapping\Aspect;
/**
 * @Aspect(order=1)
 */
class DemoAspect
{
    // TODO: ...
}
?>
order：用于指定优先级，数字越小则优先执行。
(2)、声明切点
目标类必须指定为携带 namespace 的完整路径或如示例代码中在顶部 use。
//
//// 示例代码
<?php declare(strict_types=1);

namespace App\Aspect;

use App\Services\OrderService;
use App\Services\UserService;
use Swoft\Aop\Annotation\Mapping\Aspect;
use Swoft\Aop\Annotation\Mapping\PointAnnotation;
use Swoft\Aop\Annotation\Mapping\PointBean;
use Swoft\Aop\Annotation\Mapping\PointExecution;
use Swoft\Http\Server\Annotation\Mapping\RequestMapping;

/**
 * @Aspect(order=1)
 *
 * @PointBean(
 *     include={OrderService::class,UserService::class},
 *     exclude={}
 * )
 *
 * @PointAnnotation(
 *     include={RequestMapping::class},
 *     exclude={}
 * )
 *
 * @PointExecution(
 *     include={OrderService::createOrder,UserService::getUserBalance},
 *     exclude={OrderService::generateOrder}
 * )
 */
class DemoAspect
{
    // TODO: ...
}
?>
//
//// PointBean：定义目标类切点
include：需被 指定 为切点的目标类集合；
exclude：需被 排除 为切点的目标类集合；
//
//// PointAnnotation：定义 注解类 切点，所有使用对应注解的方法均会通过该切面类代理
inlucde：需被 织入 的注解类集合；
exclude：需被 排除 的注解类集合；
//
//// PointExecution：定义确切的目标类方法。
include：需被 织入 的目标类方法集合，支持正则表达式；
exclude：需被 排除 的目标类方法集合，支持正则表达式；
使用正则表达式时，参数内容 必须 使用双引号 " " 包裹；命名空间分隔符 必须 使用 \ 转义，同时双引号内 必须 是类的完整路径。以上注解定义的关系为并集，定义的排除为并集后的结果。建议为了便于理解和使用，一个切面类尽量只使用其中一个注解。
(3)、声明通知
<?php declare(strict_types=1);

namespace App\Aspect;

use App\Services\OrderService;
use App\Services\UserService;
use Swoft\Aop\Annotation\Mapping\After;
use Swoft\Aop\Annotation\Mapping\AfterReturning;
use Swoft\Aop\Annotation\Mapping\AfterThrowing;
use Swoft\Aop\Annotation\Mapping\Around;
use Swoft\Aop\Annotation\Mapping\Aspect;
use Swoft\Aop\Annotation\Mapping\Before;
use Swoft\Aop\Annotation\Mapping\PointExecution;
use Swoft\Aop\Point\JoinPoint;
use Swoft\Aop\Point\ProceedingJoinPoint;
use Throwable;

/**
 * @Aspect(order=1)
 *
 * @PointExecution(
 *     include={OrderService::createOrder,UserService::getUserBalance},
 *     exclude={OrderService::generateOrder}
 * )
 */
class DemoAspect
{

    /**
     * 前置通知
     *
     * @Before()
     */
    public function beforeAdvice()
    {

    }

    /**
     * 后置通知
     *
     * @After()
     */
    public function afterAdvice()
    {

    }

    /**
     * 返回通知
     *
     * @AfterReturning()
     *
     * @param JoinPoint $joinPoint
     *
     * @return mixed
     */
    public function afterReturnAdvice(JoinPoint $joinPoint)
    {
        $ret = $joinPoint->getReturn();
        // 返回
        return $ret;
    }

    /**
     * 异常通知
     *
     * @AfterThrowing()
     *
     * @param Throwable $throwable
     */
    public function afterThrowingAdvice(Throwable $throwable)
    {

    }

    /**
     * 环绕通知
     *
     * @Around()
     *
     * @param ProceedingJoinPoint $proceedingJoinPoint
     *
     * @return mixed
     * @throws Throwable
     */
    public function aroundAdvice(ProceedingJoinPoint $proceedingJoinPoint)
    {
        // 前置通知
        $ret = $proceedingJoinPoint->proceed();
        // 后置通知
        return $ret;
    }
}
?>
@Before：前置通知。在目标方法之前执行
@After：后置通知。在目标方法之后执行
@AfterReturing：返回通知
@AfterThrowing：异常通知。目标方法异常时执行
@Around：环绕通知。等同于前置通知加上后置通知，在目标方法之前及之后执行
--
5、业务示例
为了更好的理解，我们使用前置、后置通知实现一个用于计算代码执行时长的例子。
(1)、控制器
///1/ 在控制器中测试更为直观
<?php declare(strict_types=1);

namespace App\Http\Controller;

use Swoft\Http\Server\Annotation\Mapping\Controller;
use Swoft\Http\Server\Annotation\Mapping\RequestMapping;

/**
 * @Controller(prefix="test")
 */
class TestRunTimeController
{

    /**
     * 闭包递归，计算阶乘
     *
     * @RequestMapping(route="factorial/{number}")
     *
     * @param int $number
     *
     * @return array
     */
    public function factorial(int $number): array
    {
        $factorial = function ($arg) use (&$factorial) {
            if ($arg == 1) {
                return $arg;
            }
            return $arg * $factorial($arg - 1);
        };
        return [$factorial($number)];
    }

    /**
     * 计算 1-1000 和，最后休眠 1s
     *
     * @RequestMapping(route="sum")
     */
    public function sumAndSleep(): array
    {
        $sum = 0;
        for ($i = 1; $i <= 1000; $i++) {
            $sum = $sum + $i;
        }
        sleep(1);
        return [$sum];
    }
}
?>
//
//// 启动 HTTP 服务后，我们可以通过访问下方两个地址执行代码
http://localhost:18306/test/factorial/100
http://localhost:18306/test/sum
(2)、切面类
前文已强调，通过 AOP 我们可以在不侵入原有代码的情况下实现额外的操作。请看示例。
<?php declare(strict_types=1);

namespace App\Aspect;

use App\Http\Controller\TestRunTimeController;
use Swoft\Aop\Annotation\Mapping\After;
use Swoft\Aop\Annotation\Mapping\Aspect;
use Swoft\Aop\Annotation\Mapping\Before;
use Swoft\Aop\Annotation\Mapping\PointBean;
use Swoft\Aop\Point\JoinPoint;

/**
 * @Aspect(order=1)
 *
 * @PointBean(include={TestRunTimeController::class})
 */
class CalculateRunTimeAspect {

    /** @var float 执行开始 */
    private $time_begin;

    /**
     * 前置通知
     *
     * @Before()
     */
    public function beforeAdvice()
    {
        // 起点时间
        $this->time_begin = microtime(true);
    }

    /**
     * 后置通知
     *
     * @After()
     *
     * @param JoinPoint $joinPoint
     */
    public function afterAdvice(JoinPoint $joinPoint)
    {
        /** @var float 执行结束 */
        $timeFinish = microtime(true);
        $method = $joinPoint->getMethod();
        $runtime = round(($timeFinish - $this->time_begin) * 1000, 3);
        echo "{$method} 方法，本次执行时间为: {$runtime}ms \n";
    }
}
?>
//
//// 编写完成后重启 HTTP 服务，然后再次访问
http://localhost:18306/test/factorial/100
http://localhost:18306/test/sum
//
//// 得到结果后返回控制台查看执行时间
factorial 方法，本次执行时间为: 0.107ms
sumAndSleep 方法，本次执行时间为: 1000.319ms
--
6、通知执行顺序
前文已提到，多个切面按照 order 属性值进行优先级划分，数字越小优先执行。而在一个切面中的多个通知同样也按照顺序执行。
(1)、单切面
///1/ 正常顺序
( 图 https://www.swoft.org/img/singular-aspect-normal.jpg )
AOP --1--> @Around --2--> @Before --3--> Method --4--> @Around --5--> @After --6--> @AfterReturning
<1>、@Around 环绕通知 前 置部分
<2>、@Before 前置通知
<3>、目标对象方法
<4>、@Around 环绕通知 后 置部分
<5>、@After 后置通知
<6>、@AfterReturn 返回通知
//
///2/ 异常顺序
( 图 https://www.swoft.org/img/singular-aspect-exception.jpg )
AOP --1--> @Around --2--> @Before --3--> Method --4--> @Around --5--> @After --6--> @AfterThrowing
<1>、@Around 环绕通知 前 置部分
<2>、@Before 前置通知
<3>、目标对象方法
<4>、@Around 环绕通知 后 置部分
<5>、@After 后置通知
<6>、@AfterThrowing 返回通知
(2)、多切面
( 图 https://www.swoft.org/img/multiple-aspects.jpg )
//// 以正常情况为例
<1>、切面 1 @Around 环绕通知 前置部分
<2>、切面 1 @Before 前置通知
<3>、切面 2 @Around 环绕通知 前置部分
<4>、切面 2 @Before 前置通知
<5>、目标对象方法
<6>、切面 2 @Around 环绕通知 后置部分
<7>、切面 2 @After 后置通知
<8>、切面 2 @AfterReturn 返回通知
<9>、切面 1 @Around 环绕通知 后置通知
<10>、切面 1 @After 后置通知
<11 >、切面 1 @AfterReturn 返回通知
--
7、注意事项
AOP 仅拦截 public 及 protected 修饰的方法，不会拦截 private 方法。
此外，在 Swoft AOP 中，如果某个方法内调用了另一个 被织入 的方法时，AOP 也会向该方法织入通知。例如我们定义了一个类 A，它有两个 public 方法 func1 和 func2，然后我们定义一个切面，使用 @PointBean(include={A::class}) 注解将 A 类（所有方法）进行织入，示例代码。
//
//// 定义了一个类 A，它有两个 public 方法 func1 和 func2，然后我们定义一个切面，使用 @PointBean(include={A::class}) 注解将 A 类（所有方法）进行织入
<?php
class A
{
    function func1()
    {
        echo "func1 \n";
    }

    function func2()
    {
        $this->func1();
        echo "func2 \n";
    }
}
?>
当我们执行 func2 时，我们的切面会被执行 两次，两次执行的顺序相同。切面会先对 func2 织入通知，其次对 func1 织入通知。
--
--
四、事件
https://www.swoft.org/documents/v2/basic-components/event/	
//
Swoft 2 对事件进行了更加清晰和严谨的规划，提供了基本的事件注册与触发管理。
GitHub: https://github.com/swoft-cloud/swoft-event
--
1、安装
默认情况下事件组件已包含在 Swoft 框架中，如需单独安装只需执行下方命令。
composer require swoft/event
--
2、简介
//// 在 Swoft 中，我们将事件分为三大类。
Swoole Server 回调事件；
Swoft Server 事件，基于 Swoole 回调处理，扩展了可用事件以方便自定义；
应用级自定义事件管理；
--
3、事件分组
除部分特殊事件外，在一个应用中，大多数事件存在关联性，此时我们可以对事件进行分组以方便识别和管理。建议根据实际情况在名称设计上对事件进行分组。
//
//// 示例
swoft.server.*
swoft.process.*
swoft.pool.*
//
swoft.http.request.before
swoft.http.request.after
//
swoft.db.query.start
swoft.db.query.after
//
swoft.redis.start
swoft.redis.after
//
swoft.ws.start
swoft.ws.after
//
swoft.tcp.start
swoft.tcp.after
//
swoft.udp.start
swoft.udp.after
--
4、通配符
//// 事件支持使用通配符 * 对一组相关事件进行监听，具体分为两种
|1>、* 全局事件通配符。直接对 * 添加监听器 @Listener("*")，此时所有触发的事件都会被此监听器所监听。
|2>、{prefix}.* 指定分组事件的监听。例如 @Listener("swoft.db.*")，此时所有以 swoft.db. 为前缀的事件（例如 swoft.db.query、swoft.db.connect）都会被此监听器所监听。
在事件到达监听器前停止本次事件的传播 $event->stopPropagation(true) 时，后面的监听器将不会收到该事件。
--
5、如何使用
(1)、监听器
//// 事件监听器类通过注解 @Listener 指定，其拥有两个属性
event：监听事件名称；
priority：监听器的优先级，数字越大优先执行；
注意：监听类必须实现接口 Swoft\Event\EventHandlerInterface。
(2)、消费者
事件消费者类通过注解 @Subscriber 指定。
(3)、监听器示例
<?php declare(strict_types=1);

namespace SwoftTest\Event\Testing;

use Swoft\Event\Annotation\Mapping\Listener;
use Swoft\Event\EventHandlerInterface;
use Swoft\Event\EventInterface;

/**
 * Class TestHandler
 *
 * @Listener("test.evt")
 */
class TestHandler implements EventHandlerInterface
{
    /**
     * @param EventInterface $event
     */
    public function handle(EventInterface $event): void
    {
        $pos = __METHOD__;
        echo "handle the event '{$event->getName()}' on the: $pos\n";
    }
}
?>
(4)、消费者示例
<?php declare(strict_types=1);

namespace SwoftTest\Event\Testing;

use Swoft\Event\Annotation\Mapping\Subscriber;
use Swoft\Event\EventInterface;
use Swoft\Event\EventSubscriberInterface;
use Swoft\Event\Listener\ListenerPriority;

/**
 * Class TestSubscriber
 *
 * @Subscriber()
 */
class TestSubscriber implements EventSubscriberInterface
{
    public const EVENT_ONE = 'test.event1';
    public const EVENT_TWO = 'test.event2';

    /**
     * Configure events and corresponding processing methods (you can configure the priority)
     * @return array
     * [
     *  'event name' => 'handler method'
     *  'event name' => ['handler method', priority]
     * ]
     */
    public static function getSubscribedEvents(): array
    {
        return [
            self::EVENT_ONE => 'handleEvent1',
            self::EVENT_TWO => ['handleEvent2', ListenerPriority::HIGH],
        ];
    }

    public function handleEvent1(EventInterface $evt): void
    {
        $evt->setParams(['msg' => 'handle the event: test.event1 position: TestSubscriber.handleEvent1()']);
    }

    public function handleEvent2(EventInterface $evt): void
    {
        $evt->setParams(['msg' => 'handle the event: test.event2 position: TestSubscriber.handleEvent2()']);
    }
}
?>
(5)、触发事件
事件名称建议放置在一个专用类的常量中，方便进行管理和维护。
//// 方式一，使用便捷，多个参数按顺序存入，因此只能通过索引获取
Swoft::trigger('event name', 'target', $arg0, $arg1);
// 获取
$target = $event->getTarget();
$arg0 = $event->getParam(0);
$arg1 = $event->getParam(1);
//
//// 方式二，多个参数按键值对的方式存入，可根据 key 获取
Swoft::triggerByArray('event name', 'target', [
    'arg0' => $arg0,
    'arg1' => $arg1
]);
// 获取
$target = $event->getTarget();
$arg0 = $event->getParam('arg0');
$arg1 = $event->getParam('arg1');
--
6、Swoft 事件
Swoft 事件基于 Swoole 的回调处理扩展了一些可用 Server 事件，提供更加精细的操作空间。完整事件列表请参阅 ServerEvent.php ( https://github.com/swoft-cloud/swoft-server/blob/master/src/ServerEvent.php ) 文件。
//
//// ServerEvent.php
<?php declare(strict_types=1);

namespace Swoft\Server;

/**
 * Class ServerEvent
 *
 * @since 2.0
 */
final class ServerEvent
{
    /**
     * Before set swoole settings
     */
    public const BEFORE_SETTING = 'swoft.server.setting.before';

    /**
     * Before add swoole events
     */
    public const BEFORE_ADDED_EVENT = 'swoft.server.added.event.before';

    /**
     * After add swoole events
     */
    public const AFTER_ADDED_EVENT = 'swoft.server.added.event.after';

    /**
     * Before add listener(s)
     */
    public const BEFORE_ADDED_LISTENER = 'swoft.server.added.listener.before';

    /**
     * After each listener is successfully added
     */
    public const AFTER_ADDED_LISTENER = 'swoft.server.added.listener.after';

    /**
     * Before add process(es)
     */
    public const BEFORE_ADDED_PROCESS = 'swoft.server.added.process.before';

    /**
     * Add process(es)
     */
    public const ADDED_PROCESS = 'swoft.server.added.process';

    /**
     * After each process is successfully added
     */
    public const AFTER_ADDED_PROCESS = 'swoft.server.added.process.after';

    /**
     * Swoft before start server event
     */
    public const BEFORE_START = 'swoft.server.start.before';

    /**
     * On task process start event
     */
    public const TASK_PROCESS_START = 'swoft.process.task.start';

    /**
     * On work process start event
     */
    public const WORK_PROCESS_START = 'swoft.process.work.start';

    /**
     * on user process start event
     */
    public const USER_PROCESS_START = 'swoft.process.user.start';

    /**
     * Server pipe-message. please {@see \Swoft\Server\Swoole\PipeMessageListener}
     */
    public const PIPE_MESSAGE = 'swoft.server.pipe.message';

    /**
     * after event
     */
    public const AFTER_EVENT = 'swoft.server.event.after';

    /**
     * Before shutdown event
     */
    public const BEFORE_SHUTDOWN_EVENT = 'swoft.server.event.shutdown.before';

    /**
     * Before start event
     */
    public const BEFORE_START_EVENT = 'swoft.server.event.start.before';

    /**
     * Before worker error event
     */
    public const BEFORE_WORKER_ERROR_EVENT = 'swoft.server.event.worker.error.before';

    /**
     * Before worker start event
     */
    public const BEFORE_WORKER_START_EVENT = 'swoft.server.event.worker.start.before';

    /**
     * Before worker stop event
     */
    public const BEFORE_WORKER_STOP_EVENT = 'swoft.server.event.worker.stop.before';

    /**
     * Before bind listener(s)
     *
     * @deprecated
     */
    public const BEFORE_BIND_LISTENER = 'swoft.server.added.listener.before';

    /**
     * Before bind swoole events
     *
     * @deprecated
     */
    public const BEFORE_BIND_EVENT = 'swoft.server.added.event.before';
}
?>
(1)、基础事件
基础事件定义请参阅 SwoftEvent.php ( http://github.com/swoft-cloud/swoft-framework/blob/master/src/SwoftEvent.php ) 文件。
//
//// SwoftEvent.php
// http://github.com/swoft-cloud/swoft-framework/blob/master/src/SwoftEvent.php
<?php declare(strict_types=1);

namespace Swoft;

/**
 * Class SwoftEvent
 *
 * @since 2.0
 */
final class SwoftEvent
{
    /**
     * Swoft init complete
     */
    public const APP_INIT_COMPLETE = 'swoft.init.complete';

    /**
     * Session complete
     *  - webSocket connection close
     *  - tcp connection close
     */
    public const SESSION_COMPLETE = 'swoft.session.complete';

    /**
     * Coroutine complete
     */
    public const COROUTINE_COMPLETE = 'swoft.co.complete';

    /**
     * Coroutine exception
     */
    public const COROUTINE_EXCEPTION = 'swoft.co.exception';

    /**
     * Coroutine destroy
     */
    public const COROUTINE_DESTROY = 'swoft.co.destroy';

    /**
     * Coroutine defer
     */
    public const COROUTINE_DEFER = 'swoft.co.defer';

    /**
     * Worker shutdown
     */
    public const WORKER_SHUTDOWN = 'swoft.worker.shutdown';

    /**
     * Timer after before
     */
    public const TIMER_AFTER_BEFORE = 'swoft.timer.after.before';

    /**
     * Timer after after
     */
    public const TIMER_AFTER_AFTER = 'swoft.timer.after.after';

    /**
     * Timer tick before
     */
    public const TIMER_TICK_BEFORE = 'swoft.timer.tick.before';

    /**
     * Timer tick after
     */
    public const TIMER_TICK_AFTER = 'swoft.timer.tick.after';
}
(2)、使用示例
我们可以在 Swoole Server 启动前注册一个自定义进程，这样可以让进程由 Server 托管。
|1>、不需要执行 Start，在 Server 启动时会自动创建进程，并执行指定的子进程函数；
|2>、在 Shutdown 关闭服务器时，会向用户进程发送 SIGTERM 信号以关闭用户进程；
|3>、自定义进程会托管到 Manager 进程，如果发生致命错误，Manager 进程会自动重建；
//
///1/ AttachMyProcessHandler
<?php declare(strict_types=1);

namespace App\Listener;

use App\Process\MyProcess;
use Swoft\Event\Annotation\Mapping\Listener;
use Swoft\Event\EventHandlerInterface;
use Swoft\Event\EventInterface;
use Swoft\Server\ServerEvent;

/**
 * Class AttachMyProcessHandler
 *
 * @Listener(ServerEvent::BEFORE_START)
 */
class AttachMyProcessHandler implements EventHandlerInterface
{
    /**
     * @param EventInterface $event
     */
    public function handle(EventInterface $event): void
    {
        $swooleServer = $event->target->getSwooleServer();

        $process = bean(MyProcess::class);

        $swooleServer->addProcess($process->create());
    }
}
?>
//
///2/ MyProcess
<?php declare(strict_types=1);

namespace App\Process;

use Swoft\Event\Annotation\Mapping\Listener;
use Swoole\Process;

/**
 * Class MyProcess
 *
 * @Bean()
 */
class MyProcess
{
    public function create(): Process
    {
        return new Process([$this, 'handle']);
    }

    public function handle(Process $process)
    {
        CLog::info('MyProcess started.');

        // 用户进程实现了广播功能，循环接收管道消息，并发给服务器的所有连接
        while (true) {
            $msg = $process->read();
            foreach($server->connections as $conn) {
                $server->send($conn, $msg);
            }
        }
    }
}
?>
--
7、Swoole 事件
Swoole 文档中的每个事件，在 Swoft 里面均可监听，并且可以存在多个监听器。
(1)、事件常量
事件常量请参阅 SwooleEvent.php ( https://github.com/swoft-cloud/swoft-server/blob/master/src/SwooleEvent.php ) 文件。
//
//// SwooleEvent.php
// https://github.com/swoft-cloud/swoft-server/blob/master/src/SwooleEvent.php
<?php declare(strict_types=1);

namespace Swoft\Server;

use Swoft\Server\Contract\CloseInterface;
use Swoft\Server\Contract\ConnectInterface;
use Swoft\Server\Contract\FinishInterface;
use Swoft\Server\Contract\HandshakeInterface;
use Swoft\Server\Contract\MessageInterface;
use Swoft\Server\Contract\PacketInterface;
use Swoft\Server\Contract\PipeMessageInterface;
use Swoft\Server\Contract\ReceiveInterface;
use Swoft\Server\Contract\RequestInterface;
use Swoft\Server\Contract\SyncTaskInterface;
use Swoft\Server\Contract\TaskInterface;

/**
 * Class SwooleEvent
 *
 * @since 2.0
 */
class SwooleEvent
{
    /**
     * Start
     */
    public const START = 'start';

    /**
     * Shutdown
     */
    public const SHUTDOWN = 'shutdown';

    /**
     * WorkerStart
     */
    public const WORKER_START = 'workerStart';

    /**
     * WorkerStop
     */
    public const WORKER_STOP = 'workerStop';

    /**
     * WorkerError
     */
    public const WORKER_ERROR = 'workerError';

    /**
     * ManagerStart
     */
    public const MANAGER_START = 'managerStart';

    /**
     * ManagerStop
     */
    public const MANAGER_STOP = 'managerStop';

    /**
     * Task
     */
    public const TASK = 'task';

    /**
     * Finish
     */
    public const FINISH = 'finish';

    /**
     * PipeMessage
     */
    public const PIPE_MESSAGE = 'pipeMessage';

    /**
     * Handshake
     */
    public const HANDSHAKE = 'handshake';

    /**
     * Message
     */
    public const MESSAGE = 'message';

    /**
     * Open
     */
    public const OPEN = 'open';

    /**
     * Request
     */
    public const REQUEST = 'request';

    /**
     * Packet
     */
    public const PACKET = 'packet';

    /**
     * Receive
     */
    public const RECEIVE = 'receive';

    /**
     * Connect
     */
    public const CONNECT = 'connect';

    /**
     * Close
     */
    public const CLOSE = 'close';

    /**
     * Event interface listener mapping
     */
    public const LISTENER_MAPPING = [
        // For http server
        self::REQUEST      => RequestInterface::class,
        // For websocket server
        self::HANDSHAKE    => HandshakeInterface::class,
        self::MESSAGE      => MessageInterface::class,
        // For tcp server
        self::CLOSE        => CloseInterface::class,
        self::RECEIVE      => ReceiveInterface::class,
        self::CONNECT      => ConnectInterface::class,
        // For udp server
        self::PACKET       => PacketInterface::class,
        // For task
        self::TASK         => [
            SyncTaskInterface::class,
            TaskInterface::class
        ],
        self::FINISH       => FinishInterface::class,
        // For process
        self::PIPE_MESSAGE => PipeMessageInterface::class,
    ];
}
(2)、使用示例
<?php declare(strict_types=1);

namespace App\Listener;

use ReflectionException;
use Swoft\Bean\Exception\ContainerException;
use Swoft\Event\Annotation\Mapping\Listener;
use Swoft\Event\EventHandlerInterface;
use Swoft\Event\EventInterface;
use Swoft\Log\Helper\CLog;
use Swoft\Server\Swoole\SwooleEvent;

/**
 * Class MasterStartListener
 *
 * @Listener(SwooleEvent::START)
 */
class MasterStartListener implements EventHandlerInterface
{
    /**
     * @param EventInterface $event
     *
     * @throws ReflectionException
     * @throws ContainerException
     */
    public function handle(EventInterface $event): void
    {
        CLog::info('Master started');
    }
}
?>
--
8、自定义事件
更多自定义事件介绍参考：https://github.com/inhere/php-event-manager/blob/master/README.md 。
//
//// Event Dispatcher
// https://github.com/inhere/php-event-manager/blob/master/README.md
//
//// 简洁、功能完善的事件管理调度实现
实现自 Psr 14 - 事件调度器；
支持对一个事件添加多个监听器；
支持设置事件优先级；
支持快速的事件组注册；
支持根据事件名称来快速的对事件组监听，eg 触发 app.run、app.end 都将同时会触发 app.* 事件；
支持通配符事件的监听；
//
(1)、项目地址
github https://github.com/inhere/php-event-manager.git
(2)、安装
//// composer 命令
composer require inhere/event
//
//// composer.json
{
    "require": {
        "inhere/event": "dev-master"
    }
}
(3)、事件调度器
事件调度器, 也可称之为事件管理器。事件的注册、监听器注册、调度(触发)都是由它管理的。
use Inhere\Event\EventManager;
$em = new EventManager();
(4)、事件监听器
监听器允许是：function 函数；一个闭包；一个监听器类(可以有多种方式)。
//
///1/ function函数
// ...(省略)
$em->attach(Mailer::EVENT_MESSAGE_SENT, 'my_function');
//
///2/ 闭包
// ...(省略)
$em->attach(Mailer::EVENT_MESSAGE_SENT, function(Event $event) {
    // $message = $event->message;
    // ... some logic
});
//
///3/ 监听器类(有多种方式)
// 类里面存在跟事件相同名称的方法，此种方式可以在类里面写多个事件的处理方法
class ExamListener1
{
    public function messageSent(EventInterface $event)
    {
        echo "handle the event {$event->getName()}\n";
    }
}
// 一个类(含有 __invoke 方法)，此时这个类对象就相当于一个闭包
class ExamListener2
{
    public function __invoke(EventInterface $event)
    {
        echo "handle the event {$event->getName()}\n";
    }
}
// 实现接口 EventHandlerInterface，触发时会自动调用 handle() 方法。
class ExamHandler implements EventHandlerInterface
{
    /**
     * @param EventInterface $event
     * @return mixed
     */
    public function handle(EventInterface $event)
    {
        // TODO: Implement handle() method.
    }
}
// 实现接口 EventSubscriberInterface，可以在一个类里面自定义监听多个事件
/**
 * Class EnumGroupListener
 * @package Inhere\Event\Examples
 */
class EnumGroupListener implements EventSubscriberInterface
{
    const TEST_EVENT = 'test';
    const POST_EVENT = 'post';

    /**
     * 配置事件与对应的处理方法
     * @return array
     */
    public static function getSubscribedEvents(): array
    {
        return [
            self::TEST_EVENT => 'onTest',
            self::POST_EVENT => ['onPost', ListenerPriority::LOW], // 还可以配置优先级
        ];
    }

    public function onTest(EventInterface $event)
    {
        $pos = __METHOD__;
        echo "handle the event {$event->getName()} on the: $pos\n";
    }

    public function onPost(EventInterface $event)
    {
        $pos = __METHOD__;
        echo "handle the event {$event->getName()} on the: $pos\n";
    }
}
(5)、快速使用
///1/ 绑定事件触发
// 事件定义(a pre-defined event)
class MessageEvent extends Event
{
    // append property ... 
    public $message;
}
//
// 事件触发(in the business)
class Mailer
{
    use EventManagerAwareTrait;

    const EVENT_MESSAGE_SENT = 'messageSent';

    public function send($message)
    {
        // ...发送 $message 的逻辑...

        $event = new MessageEvent(self::EVENT_MESSAGE_SENT);
        $event->message = $message;
        
        // 事件触发
        $this->eventManager->trigger($event);
    }
}
//
///2/ 触发事件
$em = new EventManager();
// 绑定事件
$em->attach(Mailer::EVENT_MESSAGE_SENT, 'exam_handler');
$em->attach(Mailer::EVENT_MESSAGE_SENT, function (EventInterface $event)
{
    $pos = __METHOD__;
    echo "handle the event {$event->getName()} on the: $pos\n";
});
// 这里给它设置了更高的优先级
$em->attach(Mailer::EVENT_MESSAGE_SENT, new ExamListener1(), 10);
$em->attach(Mailer::EVENT_MESSAGE_SENT, new ExamListener2());
$em->attach(Mailer::EVENT_MESSAGE_SENT, new ExamHandler());
$mailer = new Mailer();
$mailer->setEventManager($em);
// 执行，将会触发事件
$mailer->send('hello, world!');
//
///3/ 运行示例
完整的实例代码在 examples/demo.php 中。
运行: php examples/demo.php
输出：
$ php examples/exam.php
handle the event 'messageSent' on the: ExamListener1::messageSent // 更高优先级的先调用
handle the event 'messageSent' on the: exam_handler
handle the event 'messageSent' on the: {closure}
handle the event 'messageSent' on the: ExamListener2::__invoke
handle the event 'messageSent' on the: Inhere\Event\Examples\ExamHandler::handle
(6)、一组事件的监听器
除了一些特殊的事件外，在一个应用中，大多数事件是有关联的，此时我们就可以对事件进行分组，方便识别和管理使用。
//
///1/ 事件分组 推荐将相关的事件，在名称设计上进行分组
// 模型相关：
model.insert
model.update
model.delete
// DB相关：
db.connect
db.disconnect
db.query
// 应用相关：
app.start
app.run
app.stop
//
///1-1/ 一个简单的示例应用类
/**
 * Class App
 * @package Inhere\Event\Examples
 */
class App
{
    use EventManagerAwareTrait;
    
    const ON_START = 'app.start';
    const ON_STOP = 'app.stop';
    const ON_BEFORE_REQUEST = 'app.beforeRequest';
    const ON_AFTER_REQUEST = 'app.afterRequest';
    
    public function __construct(EventManager $em)
    {
        $this->setEventManager($em);

        $this->eventManager->trigger(new Event(self::ON_START, [
            'key' => 'val'
        ]));
    }

    public function run()
    {
        $sleep = 0;
        $this->eventManager->trigger(self::ON_BEFORE_REQUEST);

        echo 'request handling ';
        while ($sleep <= 3) {
            $sleep++;
            echo '.';
            sleep(1);
        }
        echo "\n";

        $this->eventManager->trigger(self::ON_AFTER_REQUEST);
    }

    public function __destruct()
    {
        $this->eventManager->trigger(new Event(self::ON_STOP, [
            'key1' => 'val1'
        ]));
    }
}
//
///1-2/ 此应用的监听器类
将每个事件的监听器写一个类，显得有些麻烦。我们可以只写一个类用里面不同的方法来处理不同的事件。
// 方式一： 类里面存在跟事件名称相同的方法(app.start -> start())。这种方式简单快捷，但是有一定的限制 - 事件名与方法的名称必须相同。
/**
 * Class AppListener
 * @package Inhere\Event\Examples
 */
class AppListener
{
    public function start(EventInterface $event)
    {
        $pos = __METHOD__;
        echo "handle the event {$event->getName()} on the: $pos\n";
    }

    public function beforeRequest(EventInterface $event)
    {
        $pos = __METHOD__;
        echo "handle the event {$event->getName()} on the: $pos\n";
    }

    public function afterRequest(EventInterface $event)
    {
        $pos = __METHOD__;
        echo "handle the event {$event->getName()} on the: $pos\n";
    }

    public function stop(EventInterface $event)
    {
        $pos = __METHOD__;
        echo "handle the event {$event->getName()} on the: $pos\n";
    }
}
//
// 方式二：实现接口 EventSubscriberInterface，有时候我们并不想将处理方法定义成事件名称一样，想自定义。此时我们可以实现接口 EventSubscriberInterface，通过里面的 getSubscribedEvents() 来自定义事件和对应的处理方法。运行示例请看 examples/enum-group.php。
/**
 * Class EnumGroupListener
 * @package Inhere\Event\Examples
 */
class EnumGroupListener implements EventSubscriberInterface
{
    const TEST_EVENT = 'test';
    const POST_EVENT = 'post';

    /**
     * 配置事件与对应的处理方法
     * @return array
     */
    public static function getSubscribedEvents(): array
    {
        return [
            self::TEST_EVENT => 'onTest',
            self::POST_EVENT => ['onPost', ListenerPriority::LOW], // 还可以配置优先级
        ];
    }

    public function onTest(EventInterface $event)
    {
        $pos = __METHOD__;
        echo "handle the event {$event->getName()} on the: $pos\n";
    }

    public function onPost(EventInterface $event)
    {
        $pos = __METHOD__;
        echo "handle the event {$event->getName()} on the: $pos\n";
    }
}
//
///1-3/ 添加监听
// 这里使用方式一
$em = new EventManager();
// register a group listener
$em->attach('app', new AppListener());
// create app
$app = new App($em);
// run
$app->run();
//
///1-4/ 运行示例
完整的示例代码在 examples/named-group.php 中。
运行: php examples/named-group.php
输出：
$ php examples/named-group.php
handle the event 'app.start' on the: Inhere\Event\Examples\AppListener::start
handle the event 'app.beforeRequest' on the: Inhere\Event\Examples\AppListener::beforeRequest
request handling ....
handle the event 'app.afterRequest' on the: Inhere\Event\Examples\AppListener::afterRequest
handle the event 'app.stop' on the: Inhere\Event\Examples\AppListener::stop
(7)、事件通配符 *
///1/ 支持使用事件通配符 * 对一组相关的事件进行监听, 分两种。
* 全局的事件通配符。直接对 * 添加监听器($em->attach('*', 'global_listener')), 此时所有触发的事件都会被此监听器接收到。
{prefix}.* 指定分组事件的监听。eg $em->attach('db.*', 'db_listener'), 此时所有触发的以 db. 为前缀的事件(eg db.query db.connect)都会被此监听器接收到。
//
当然，你在事件到达监听器前停止了本次事件的传播$event->stopPropagation(true);，就不会被后面的监听器接收到了。
//
///2/ 示例，在上面的组事件监听器改下，添加一个 app.* 的事件监听。
// AppListener 新增一个方法
class AppListener
{
    // ...

    public function allEvent(EventInterface $event)
    {
        $pos = __METHOD__;
        echo "handle the event '{$event->getName()}' on the: $pos\n";
    }
}
// ...
$em = new EventManager();
$groupListener = new AppListener();
// register a group listener
$em->attach('app', $groupListener);
// all `app.` prefix events will be handled by `AppListener::allEvent()`
$em->attach('app.*', [$groupListener, 'allEvent']);
// create app
$app = new App($em);
// run
$app->run();
//
///3/ 运行示例
运行: php examples/named-group.php 输出：(可以看到每个事件都经过了AppListener::allEvent()的处理)
$ php examples/named-group.php
handle the event 'app.start' on the: Inhere\Event\Examples\AppListener::start
handle the event 'app.start' on the: Inhere\Event\Examples\AppListener::allEvent
handle the event 'app.beforeRequest' on the: Inhere\Event\Examples\AppListener::beforeRequest
handle the event 'app.beforeRequest' on the: Inhere\Event\Examples\AppListener::allEvent
request handling ....
handle the event 'app.afterRequest' on the: Inhere\Event\Examples\AppListener::afterRequest
handle the event 'app.afterRequest' on the: Inhere\Event\Examples\AppListener::allEvent
handle the event 'app.stop' on the: Inhere\Event\Examples\AppListener::stop
handle the event 'app.stop' on the: Inhere\Event\Examples\AppListener::allEvent
(8)、事件对象
事件对象 - 装载了在触发事件时相关的上下文信息，用户自定义的。
//
///1/ 预先创建一个事件
/// 直接简单的使用类 Event
$myEvent = new Event('name', 'target', [ 'some params ...' ]);
//
/// 使用继承了 Event 的子类，这样你可以追加自定义数据。
// create event class
class MessageEvent extends Event
{
    protected $name = 'messageSent';
    
    // append property ... 
    public $message;
}
--
9、参与贡献
欢迎参与贡献，您可以 Fork 我们的组件仓库( swoft/component )；修改代码然后发送 PR；阅读 提交代码 的注意事项。
--
--
五、配置
https://www.swoft.org/documents/v2/basic-components/config/
Swoft 配置由两部分组成，env 环境配置和 config 应用配置。
env 一般配置一些和环境相关的一些参数，比如运行模式、资源地址
config 一般用于配置应用级别的配置以及业务级别的配置
--
1、安装
composer require swoft/config
--
2、Git仓库
Github https://github.com/swoft-cloud/swoft-config
--
3、环境配置
(1)、文件配置
项目根目录配置一个名称为 .env 文件，采用 KV 格式配置，此文件配置的数据，可以加载到内存里面，供业务使用。
APP_DEBUG = 1
SWOFT_DEBUG = 1
(2)、系统变量
除文件方式配置外，还可以把一些参数配置到系统变量，系统变量的参数也会加载到内存，供业务使用。
(3)、如何使用
swoft 提供了函数读取以上两种方式配置的数据。
//
//// 获取一个环境变量的值或所有环境变量参数
env(string $key = null, mixed $default = null): mixed
返回环境变量 key 的值， 如果环境变量 key 不存在则返回默认值。 如果省略 key 参数，则所有环境变量都将作为关联数组 array 返回。
default 默认值，可以是任何类型，也可以是一个 闭包。
返回值默认做了转换。比如配置 true 字符串，返回的转换成一个 bool 类型。
(4)、特殊规则
配置(string)	转换类型结果
true/false/(true)/(false)	bool
empty|string(空字符串)	
null|null	
A_B|如果是存在的常量，转成对应的值	
--
4、应用配置
(1)、bean配置
应用配置数据是由一个bean对象管理的，可以在 app/bean.php 文件设置应用配置参数。
return [
    'config'   => [
        'path' => __DIR__ . '/../config',
    ],
];
//// 可配置项
path 自定配置文件路径。
base 主文件名称，默认 base (其他文件的数据都会按文件名为key合并到主文件数据中)。
type 配置文件类型，默认 php 同时也支持 yaml 格式。
parser 配置解析器，默认已经配置 php/yaml 解析器。
env 配置当前环境比如 dev/test/pre/pro。
(2)、数据格式
配置目录所有配置文件会解析成一个数组，但是不会递归合并数据，只会合并当前目录文件数据，以它的文件名称为数组 key 进行合并数组。 比如 config 目录配置文件如下:
|-- base.php
|-- data.php
`-- pro
    |-- base.php
    `-- data.php
只会解析当前目录文件数据，不会递归解析数据。当前使用 env 配置时，环境目录里面的配置信息会覆盖最外层文件名称相同的数据。提醒：配置文件里面可以使用 env()函数读取环境配置。
// config/base.php
return [
    'key' => 'value'
];
// config/data.php
return [
    'dkey' => [
        'dvalue'
    ],
    'key' => 'value'
];
// config/pro/base.php
return [
    'key' => 'valuePro'
];
// config/pro/data.php
return [
    'dkey' => [
        'dvalue'
    ],
    'key' => 'valuePro'
];
//// 如上配置文件，当不配置 config 的 env 参数，合并的数据格式如下
return [
    'key' => 'value',
    'data' => [
        'dkey' => [
            'dvalue'
        ],
        'key' => 'value'
    ]
];
//
//// 当配置 config 对象的 'env' => 'pro' 参数，合并的数据格式如下
return [
    'key' => 'valuePro',
    'data' => [
        'dkey' => [
            'dvalue'
        ],
        'key' => 'valuePro'
    ]
];
(3)、获取配置
框架提供全局函数、注解、config 对象多种方式，使用应用配置数据。
///1/ 函数 全局函数使用 config()
config(string $key = null, mixed $default = null):mixed
key 配置参数 key，子数组可以使用 . 分割，比如上面的例子 data.dkey 可以获取到 ["dvalue"], 当key=null 获取所有配置参数。
default 默认参数，如果 key 参数不存在，返回默认值，默认值可以是任意类型。
//
///2/ 注解
通过容器使用注解的方式，注入配置到属性值。
use Swoft\Bean\Annotation\Mapping\Bean;
use Swoft\Config\Annotation\Mapping\Config;
/**
* @Bean()
*/
class Demo
{
    /**
    * @Config("data.dkey")
    */
    private $dvalue = [];
    
    // ...
}
此例子和上面功能一样，都是读取相同的数据，两种不同的方式。使用注解，一定要保证类是一个bean对象(通过其它注解注入到容器)。
//
///3/ 对象
如果上面两种方式还不能满足你的业务需求，你可以从容器里面获取配置对象，里面自带很多方式操作配置数据。
$config = \Swoft::getBean('config');
/// config 对象常用方法
get(string $key, $default = null) 获取参数；
offsetGet($key) 获取参数；
…
--
5、参与贡献
欢迎参与贡献，您可以 fork 我们的开发仓库 swoft/component ( https://github.com/swoft-cloud/swoft-component )；修改代码然后发起 PR；关于发起PR的注意事项( https://github.com/swoft-cloud/swoft/issues/829 )。
--
--
六、公共方法
https://www.swoft.org/documents/v2/basic-components/public-function/
--
0、简介
框架中内置封装了一些公共函数，开发者在实际业务中可以直接使用，无需重复封装。其中包括：协程函数、数组函数、目录（文件夹）函数、环境函数、文件函数、文件系统函数、对象函数、PHP 助手函数、字符串函数、系统函数、XML 函数、通用函数。
--
1、协程函数
(1)、创建协程
Swoft 框架中不能使用 Swoole 提供的 go 函数创建协程，否则会造成请求和上下文丢失最终导致一些不可预估的问题。Swoft 拥有两种方式创建协程。
//
///1/ 方式一
 use Swoft\Co;
 Co::create(function () {
     // to do
 });
//
///2/ 方式二，通过助手函数 sgo 创建
sgo(function () {
    // todo
});
sgo 函数使用与 Swoole 中的 go 函数完全一致，再次强调，框架中只能使用 sgo 函数创建协程。
(2)、协程 ID
// 获取当前协程 ID，-1 为非协程环境
use Swoft\Co;
$id = Co::id();
(3)、顶级协程 ID
// 获取顶级（最外层）协程 ID
use Swoft\Co;
$id = Co::tid();
(4)、读文件
读取成功返回字符串内容，读取失败返回 false，可使用 swoole_last_error 获取错误信息。`readFile` 方法没有文件大小限制，读取的内容会存放在内存中，因此读取大文件时会占用大量内存。
// 使用示例
use Swoft\Co;
$fileName = 'file.txt'; //$filename: 带完整路径的文件名称;
$data = Co::readFile($fileName);
(5)、写文件
// 写入成功返回 true，失败返回 false。
use Swoft\Co;
$fileName = 'file.txt';
$data = Co::writeFile($fileName, 'Swoft Framework');
$filename：带完整路径的文件的名称，须有可写权限，文件不存在时会自动创建，打开文件失败会直接返回 false。
$data：写入内容，大小限制为 4M。
$flags：写入选项，默认值为 FILE_USE_INCLUDE_PATH 常量。可选值参考：文件系统 - 预定义常量 - PHP Manual ( https://www.php.net/manual/zh/filesystem.constants.php )。
(6)、并发
框架底层通过协程通道，封装了一套混合 IO 并发操作的方法，一般用于没有依赖的多个流程。
<?php

use Co\Http\Client;
use Swoft\Co;

/**
 * Class CoTest
 *
 * @since 2.0
 */
class CoTest
{

    public function testMulti()
    {
        $requests = [
            'method' => [$this, 'requestMethod'], //对象方法；
            'staticMethod' => self::requestMehtodByStatic(), //对象静态方法;
            'closure' => function () { //闭包函数;
                $cli = new Client('www.baidu.com', 80);
                $cli->get('/');
                $result = $cli->body;
                $cli->close();

                return $result;
            }
        ];

        $response = Co::multi($requests);
    }

    public function requestMethod()
    {
        $cli = new Client('www.baidu.com', 80);
        $cli->get('/');
        $result = $cli->body;
        $cli->close();

        return $result;
    }

    public static function requestMehtodByStatic()
    {
        $cli = new Client('www.baidu.com', 80);
        $cli->get('/');
        $result = $cli->body;
        $cli->close();

        return $result;
    }
}
?>
//// 参数说明
$requests：多个操作集合，requests 支持多种格式，对象方法、对象静态方法、闭包函数。
$timeout：超时时间，默认永不超时。
并发执行结果按照 requests 数组中 key 对应关系返回。如果某个 key 对应的值为 false，意味着该操作执行失败。requests 内每个操作可执行的业务不存在上限，根据实际业务而定。
--
2、数组函数
数组函数需引入 Swoft\Stdlib\Helper\Arr 或 Swoft\Stdlib\Helper\ArrayHelper，详情参阅：ArrayHelper.php 文件( https://github.com/swoft-cloud/swoft-stdlib/blob/master/src/Helper/ArrayHelper.php )。
<?php declare(strict_types=1);

namespace Swoft\Stdlib\Helper;

use ArrayAccess;
use Closure;
use InvalidArgumentException;
use Iterator;
use stdClass;
use Swoft\Stdlib\Collection;
use Swoft\Stdlib\Contract\Arrayable;
use Traversable;
use function array_pop;
use function count;
use function func_get_args;
use function get_class;
use function in_array;
use function is_array;
use function is_float;
use function is_int;
use function is_numeric;
use function is_object;
use function is_string;
use function mb_strlen;
use function method_exists;
use function similar_text;
use function value;

/**
 * Array helper
 *
 * @since 2.0
 */
class ArrayHelper
{
    /**
     * Converts an object or an array of objects into an array.
     *
     * @param object|array|string $object     the object to be converted into an array
     * @param array               $properties a mapping from object class names to the properties that need to put into the resulting arrays.
     *                                        The properties specified for each class is an array of the following format:
     *
     * @param boolean             $recursive  whether to recursively converts properties which are objects into arrays.
     *
     * @return array the array representation of the object
     */
    public static function toArray($object, $properties = [], $recursive = true): array
    {
        if (is_array($object)) {
            if ($recursive) {
                /** @var array $object */
                foreach ($object as $key => $value) {
                    if (is_array($value) || is_object($value)) {
                        $object[$key] = static::toArray($value, $properties, true);
                    }
                }
            }

            return $object;
        }

        if (is_object($object)) {
            if (!empty($properties)) {
                $className = get_class($object);
                if (!empty($properties[$className])) {
                    $result = [];
                    foreach ($properties[$className] as $key => $name) {
                        if (is_int($key)) {
                            $result[$name] = $object->$name;
                        } else {
                            $result[$key] = static::getValue($object, $name);
                        }
                    }

                    return $recursive ? static::toArray($result, $properties) : $result;
                }
            }
            if ($object instanceof Arrayable) {
                $result = $object->toArray();
            } else {
                $result = [];
                /** @var array $object */
                foreach ($object as $key => $value) {
                    $result[$key] = $value;
                }
            }

            return $recursive ? static::toArray($result, $properties) : $result;
        }

        return [$object];
    }

    /**
     * Merges two or more arrays into one recursively.
     * If each array has an element with the same string key value, the latter
     * will overwrite the former (different from array_merge_recursive).
     * Recursive merging will be conducted if both arrays have an element of array
     * type and are having the same key.
     * For integer-keyed elements, the elements from the latter array will
     * be appended to the former array.
     *
     * @param array $a array to be merged to
     * @param array $b array to be merged from. You can specify additional
     *                 arrays via third argument, fourth argument etc.
     *
     * @return array the merged array (the original arrays are not changed.)
     */
    public static function merge($a, $b): array
    {
        $args = func_get_args();
        $res  = array_shift($args);
        while (!empty($args)) {
            $next = array_shift($args);
            foreach ($next as $k => $v) {
                if (is_int($k)) {
                    if (isset($res[$k])) {
                        $res[] = $v;
                    } else {
                        $res[$k] = $v;
                    }
                } elseif (is_array($v) && isset($res[$k]) && is_array($res[$k])) {
                    $res[$k] = self::merge($res[$k], $v);
                } else {
                    $res[$k] = $v;
                }
            }
        }

        return $res;
    }

    /**
     * Retrieves the value of an array element or object property with the given key or property name.
     * If the key does not exist in the array or object, the default value will be returned instead.
     *
     * The key may be specified in a dot format to retrieve the value of a sub-array or the property
     * of an embedded object. In particular, if the key is `x.y.z`, then the returned value would
     * be `$array['x']['y']['z']` or `$array->x->y->z` (if `$array` is an object). If `$array['x']`
     * or `$array->x` is neither an array nor an object, the default value will be returned.
     * Note that if the array already has an element `x.y.z`, then its value will be returned
     * instead of going through the sub-arrays. So it is better to be done specifying an array of key names
     * like `['x', 'y', 'z']`.
     *
     * Below are some usage examples,
     *
     * ```php
     * // working with array
     * $username = \Swoft\Helper\ArrayHelper::getValue($_POST, 'username');
     * // working with object
     * $username = \Swoft\Helper\ArrayHelper::getValue($user, 'username');
     * // working with anonymous function
     * $fullName = \Swoft\Helper\ArrayHelper::getValue($user, function ($user, $defaultValue) {
     *     return $user->firstName . ' ' . $user->lastName;
     * });
     * // using dot format to retrieve the property of embedded object
     * $street = \Swoft\Helper\ArrayHelper::getValue($users, 'address.street');
     * // using an array of keys to retrieve the value
     * $value = \Swoft\Helper\ArrayHelper::getValue($versions, ['1.0', 'date']);
     * ```
     *
     * @param array|object         $array    array or object to extract value from
     * @param string|Closure|array $key      key name of the array element, an array of keys or property name of the object,
     *                                       or an anonymous function returning the value. The anonymous function signature should be:
     *                                       `function($array, $defaultValue)`.
     * @param mixed                $default  the default value to be returned if the specified array key does not exist. Not used when
     *                                       getting value from an object.
     *
     * @return mixed the value of the element if found, default value otherwise
     */
    public static function getValue($array, $key, $default = null)
    {
        if ($key instanceof Closure) {
            return $key($array, $default);
        }

        if (is_array($key)) {
            $lastKey = array_pop($key);
            /** @var array $key */
            foreach ($key as $keyPart) {
                $array = static::getValue($array, $keyPart);
            }
            $key = $lastKey;
        }

        if (is_array($array) && (isset($array[$key]) || array_key_exists($key, $array))) {
            return $array[$key];
        }

        if (is_string($key) && ($pos = strrpos($key, '.')) !== false) {
            $array = static::getValue($array, substr($key, 0, $pos), $default);
            $key   = (string)substr($key, $pos + 1);
        }

        if (is_object($array)) {
            // this is expected to fail if the property does not exist, or __get() is not implemented
            // it is not reliably possible to check whether a property is accessable beforehand
            return $array->$key;
        }

        if (is_array($array)) {
            return (isset($array[$key]) || array_key_exists($key, $array)) ? $array[$key] : $default;
        }

        return $default;
    }

    /**
     * Removes an item from an array and returns the value. If the key does not exist in the array, the default value
     * will be returned instead.
     *
     * Usage examples,
     *
     * ```php
     * // $array = ['type' => 'A', 'options' => [1, 2]];
     * // working with array
     * $type = \Swoft\Helper\ArrayHelper::remove($array, 'type');
     * // $array content
     * // $array = ['options' => [1, 2]];
     * ```
     *
     * @param array  $array   the array to extract value from
     * @param string $key     key name of the array element
     * @param mixed  $default the default value to be returned if the specified key does not exist
     *
     * @return mixed|null the value of the element if found, default value otherwise
     */
    public static function remove(&$array, $key, $default = null)
    {
        if (is_array($array) && (isset($array[$key]) || array_key_exists($key, $array))) {
            $value = $array[$key];
            unset($array[$key]);

            return $value;
        }

        return $default;
    }

    /**
     * Get all of the given array except for a specified array of keys.
     *
     * @param array        $array
     * @param array|string $keys
     *
     * @return array
     */
    public static function except($array, $keys): array
    {
        static::forget($array, $keys);

        return $array;
    }

    /**
     * Remove one or many array items from a given array using "dot" notation.
     *
     * @param array        $array
     * @param array|string $keys
     *
     * @return void
     */
    public static function forget(&$array, $keys): void
    {
        $original = &$array;

        $keys = (array)$keys;

        if (count($keys) === 0) {
            return;
        }

        foreach ($keys as $key) {
            // if the exact key exists in the top-level, remove it
            if (static::exists($array, $key)) {
                unset($array[$key]);

                continue;
            }

            $parts = explode('.', $key);

            // clean up before each pass
            $array = &$original;

            while (count($parts) > 1) {
                $part = array_shift($parts);

                if (isset($array[$part]) && is_array($array[$part])) {
                    $array = &$array[$part];
                } else {
                    continue 2;
                }
            }

            unset($array[array_shift($parts)]);
        }
    }

    /**
     * Get a value from the array, and remove it.
     *
     * @param array  $array
     * @param string $key
     * @param mixed  $default
     *
     * @return mixed
     */
    public static function pull(&$array, $key, $default = null)
    {
        $value = static::get($array, $key, $default);

        static::forget($array, $key);

        return $value;
    }

    /**
     * Indexes and/or groups the array according to a specified key.
     * The input should be either multidimensional array or an array of objects.
     *
     * The $key can be either a key name of the sub-array, a property name of object, or an anonymous
     * function that must return the value that will be used as a key.
     *
     * $groups is an array of keys, that will be used to group the input array into one or more sub-arrays based
     * on keys specified.
     *
     * If the `$key` is specified as `null` or a value of an element corresponding to the key is `null` in addition
     * to `$groups` not specified then the element is discarded.
     *
     * For example:
     *
     * ```php
     * $array = [
     *     ['id' => '123', 'Data' => 'abc', 'device' => 'laptop'],
     *     ['id' => '345', 'Data' => 'def', 'device' => 'tablet'],
     *     ['id' => '345', 'Data' => 'hgi', 'device' => 'smartphone'],
     * ];
     * $result = ArrayHelper::index($array, 'id');
     * ```
     *
     * The result will be an associative array, where the key is the value of `id` attribute
     *
     * ```php
     * [
     *     '123' => ['id' => '123', 'Data' => 'abc', 'device' => 'laptop'],
     *     '345' => ['id' => '345', 'Data' => 'hgi', 'device' => 'smartphone']
     *     // The second element of an original array is overwritten by the last element because of the same id
     * ]
     * ```
     *
     * An anonymous function can be used in the grouping array as well.
     *
     * ```php
     * $result = ArrayHelper::index($array, function ($element) {
     *     return $element['id'];
     * });
     * ```
     *
     * Passing `id` as a third argument will group `$array` by `id`:
     *
     * ```php
     * $result = ArrayHelper::index($array, null, 'id');
     * ```
     *
     * The result will be a multidimensional array grouped by `id` on the first level, by `device` on the second level
     * and indexed by `Data` on the third level:
     *
     * ```php
     * [
     *     '123' => [
     *         ['id' => '123', 'Data' => 'abc', 'device' => 'laptop']
     *     ],
     *     '345' => [ // all elements with this index are present in the result array
     *         ['id' => '345', 'Data' => 'def', 'device' => 'tablet'],
     *         ['id' => '345', 'Data' => 'hgi', 'device' => 'smartphone'],
     *     ]
     * ]
     * ```
     *
     * The anonymous function can be used in the array of grouping keys as well:
     *
     * ```php
     * $result = ArrayHelper::index($array, 'Data', [function ($element) {
     *     return $element['id'];
     * }, 'device']);
     * ```
     *
     * The result will be a multidimensional array grouped by `id` on the first level, by the `device` on the second one
     * and indexed by the `Data` on the third level:
     *
     * ```php
     * [
     *     '123' => [
     *         'laptop' => [
     *             'abc' => ['id' => '123', 'Data' => 'abc', 'device' => 'laptop']
     *         ]
     *     ],
     *     '345' => [
     *         'tablet' => [
     *             'def' => ['id' => '345', 'Data' => 'def', 'device' => 'tablet']
     *         ],
     *         'smartphone' => [
     *             'hgi' => ['id' => '345', 'Data' => 'hgi', 'device' => 'smartphone']
     *         ]
     *     ]
     * ]
     * ```
     *
     * @param array                          $array   the array that needs to be indexed or grouped
     * @param string|Closure|null            $key     the column name or anonymous function which result will be used to index the array
     * @param string|string[]|Closure[]|null $groups  the array of keys, that will be used to group the input array
     *                                                by one or more keys. If the $key attribute or its value for the particular element is null and $groups is not
     *                                                defined, the array element will be discarded. Otherwise, if $groups is specified, array element will be added
     *                                                to the result array without any key.
     *
     * @return array the indexed and/or grouped array
     */
    public static function index($array, $key, $groups = []): array
    {
        $result = [];
        $groups = (array)$groups;

        foreach ($array as $element) {
            $lastArray = &$result;

            foreach ($groups as $group) {
                $value = static::getValue($element, $group);
                if (!array_key_exists($value, $lastArray)) {
                    $lastArray[$value] = [];
                }
                $lastArray = &$lastArray[$value];
            }

            if ($key === null) {
                if (!empty($groups)) {
                    $lastArray[] = $element;
                }
            } else {
                $value = static::getValue($element, $key);
                if ($value !== null) {
                    if (is_float($value)) {
                        $value = (string)$value;
                    }
                    $lastArray[$value] = $element;
                }
            }
            unset($lastArray);
        }

        return $result;
    }

    /**
     * Returns the values of a specified column in an array.
     * The input array should be multidimensional or an array of objects.
     *
     * For example,
     *
     * ```php
     * $array = [
     *     ['id' => '123', 'Data' => 'abc'],
     *     ['id' => '345', 'Data' => 'def'],
     * ];
     * $result = ArrayHelper::getColumn($array, 'id');
     * // the result is: ['123', '345']
     *
     * // using anonymous function
     * $result = ArrayHelper::getColumn($array, function ($element) {
     *     return $element['id'];
     * });
     * ```
     *
     * @param array          $array
     * @param string|Closure $name
     * @param boolean        $keepKeys  whether to maintain the array keys. If false, the resulting array
     *                                  will be re-indexed with integers.
     *
     * @return array the list of column values
     */
    public static function getColumn($array, $name, $keepKeys = true): array
    {
        $result = [];
        if ($keepKeys) {
            foreach ($array as $k => $element) {
                $result[$k] = static::getValue($element, $name);
            }
        } else {
            foreach ($array as $element) {
                $result[] = static::getValue($element, $name);
            }
        }

        return $result;
    }

    /**
     * Builds a map (key-value pairs) from a multidimensional array or an array of objects.
     * The `$from` and `$to` parameters specify the key names or property names to set up the map.
     * Optionally, one can further group the map according to a grouping field `$group`.
     *
     * For example,
     *
     * ```php
     * $array = [
     *     ['id' => '123', 'name' => 'aaa', 'class' => 'x'],
     *     ['id' => '124', 'name' => 'bbb', 'class' => 'x'],
     *     ['id' => '345', 'name' => 'ccc', 'class' => 'y'],
     * ];
     *
     * $result = ArrayHelper::map($array, 'id', 'name');
     * // the result is:
     * // [
     * //     '123' => 'aaa',
     * //     '124' => 'bbb',
     * //     '345' => 'ccc',
     * // ]
     *
     * $result = ArrayHelper::map($array, 'id', 'name', 'class');
     * // the result is:
     * // [
     * //     'x' => [
     * //         '123' => 'aaa',
     * //         '124' => 'bbb',
     * //     ],
     * //     'y' => [
     * //         '345' => 'ccc',
     * //     ],
     * // ]
     * ```
     *
     * @param array          $array
     * @param string|Closure $from
     * @param string|Closure $to
     * @param string|Closure $group
     *
     * @return array
     */
    public static function map($array, $from, $to, $group = null): array
    {
        $result = [];
        foreach ($array as $element) {
            $key   = static::getValue($element, $from);
            $value = static::getValue($element, $to);
            if ($group !== null) {
                $result[static::getValue($element, $group)][$key] = $value;
            } else {
                $result[$key] = $value;
            }
        }

        return $result;
    }

    /**
     * Checks if the given array contains the specified key.
     * This method enhances the `array_key_exists()` function by supporting case-insensitive
     * key comparison.
     *
     * @param string  $key           the key to check
     * @param array   $array         the array with keys to check
     * @param boolean $caseSensitive whether the key comparison should be case-sensitive
     *
     * @return boolean whether the array contains the specified key
     */
    public static function keyExists($key, $array, $caseSensitive = true): ?bool
    {
        if ($caseSensitive) {
            return array_key_exists($key, $array);
        } else {
            foreach (array_keys($array) as $k) {
                if (strcasecmp($key, $k) === 0) {
                    return true;
                }
            }

            return false;
        }
    }

    /**
     * Sorts an array of objects or arrays (with the same structure) by one or several keys.
     *
     * @param array                $array      the array to be sorted. The array will be modified after calling this method.
     * @param string|Closure|array $key        the key(s) to be sorted by. This refers to a key name of the sub-array
     *                                         elements, a property name of the objects, or an anonymous function returning the values for comparison
     *                                         purpose. The anonymous function signature should be: `function($item)`.
     *                                         To sort by multiple keys, provide an array of keys here.
     * @param integer|array        $direction  the sorting direction. It can be either `SORT_ASC` or `SORT_DESC`.
     *                                         When sorting by multiple keys with different sorting directions, use an array of sorting directions.
     * @param integer|array        $sortFlag   the PHP sort flag. Valid values include
     *                                         `SORT_REGULAR`, `SORT_NUMERIC`, `SORT_STRING`, `SORT_LOCALE_STRING`, `SORT_NATURAL` and `SORT_FLAG_CASE`.
     *                                         Please refer to [PHP manual](http://php.net/manual/en/function.sort.php)
     *                                         for more details. When sorting by multiple keys with different sort flags, use an array of sort flags.
     *
     * @throws InvalidArgumentException if the $direction or $sortFlag parameters do not have
     * correct number of elements as that of $key.
     */
    public static function multisort(&$array, $key, $direction = SORT_ASC, $sortFlag = SORT_REGULAR): void
    {
        $keys = is_array($key) ? $key : [$key];
        if (empty($keys) || empty($array)) {
            return;
        }
        $n = count($keys);
        if (is_scalar($direction)) {
            $direction = array_fill(0, $n, $direction);
        } elseif (count($direction) !== $n) {
            throw new InvalidArgumentException('The length of $direction parameter must be the same as that of $keys.');
        }
        if (is_scalar($sortFlag)) {
            $sortFlag = array_fill(0, $n, $sortFlag);
        } elseif (count($sortFlag) !== $n) {
            throw new InvalidArgumentException('The length of $sortFlag parameter must be the same as that of $keys.');
        }
        $args = [];
        foreach ($keys as $i => $k) {
            $flag   = $sortFlag[$i];
            $args[] = static::getColumn($array, $k);
            $args[] = $direction[$i];
            $args[] = $flag;
        }

        // This fix is used for cases when main sorting specified by columns has equal values
        // Without it it will lead to Fatal Error: Nesting level too deep - recursive dependency?
        $args[] = range(1, count($array));
        $args[] = SORT_ASC;
        $args[] = SORT_NUMERIC;

        $args[] = &$array;
        array_multisort(...$args);
    }

    /**
     * Returns a value indicating whether the given array is an associative array.
     *
     * An array is associative if all its keys are strings. If `$allStrings` is false,
     * then an array will be treated as associative if at least one of its keys is a string.
     *
     * Note that an empty array will NOT be considered associative.
     *
     * @param array   $array      the array being checked
     * @param boolean $allStrings whether the array keys must be all strings in order for
     *                            the array to be treated as associative.
     *
     * @return boolean whether the array is associative
     */
    public static function isAssociative($array, $allStrings = true): ?bool
    {
        if (!is_array($array) || empty($array)) {
            return false;
        }

        if ($allStrings) {
            foreach ($array as $key => $value) {
                if (!is_string($key)) {
                    return false;
                }
            }

            return true;
        } else {
            foreach ($array as $key => $value) {
                if (is_string($key)) {
                    return true;
                }
            }

            return false;
        }
    }

    /**
     * Returns a value indicating whether the given array is an indexed array.
     *
     * An array is indexed if all its keys are integers. If `$consecutive` is true,
     * then the array keys must be a consecutive sequence starting from 0.
     *
     * Note that an empty array will be considered indexed.
     *
     * @param array   $array       the array being checked
     * @param boolean $consecutive whether the array keys must be a consecutive sequence
     *                             in order for the array to be treated as indexed.
     *
     * @return boolean whether the array is associative
     */
    public static function isIndexed($array, $consecutive = false): ?bool
    {
        if (!is_array($array)) {
            return false;
        }

        if (empty($array)) {
            return true;
        }

        if ($consecutive) {
            return array_keys($array) === range(0, count($array) - 1);
        } else {
            foreach ($array as $key => $value) {
                if (!is_int($key)) {
                    return false;
                }
            }

            return true;
        }
    }

    /**
     * Check whether an array or [[\Traversable]] contains an element.
     *
     * This method does the same as the PHP function [in_array()](http://php.net/manual/en/function.in-array.php)
     * but additionally works for objects that implement the [[\Traversable]] interface.
     *
     * @param mixed             $needle   The value to look for.
     * @param array|Traversable $haystack The set of values to search.
     * @param boolean           $strict   Whether to enable strict (`===`) comparison.
     *
     * @return boolean `true` if `$needle` was found in `$haystack`, `false` otherwise.
     * @throws InvalidArgumentException if `$haystack` is neither traversable nor an array.
     * @see   http://php.net/manual/en/function.in-array.php
     */
    public static function isIn($needle, $haystack, $strict = false): bool
    {
        if ($haystack instanceof Traversable) {
            foreach ($haystack as $value) {
                if ($needle == $value && (!$strict || $needle === $value)) {
                    return true;
                }
            }
        } elseif (is_array($haystack)) {
            return in_array($needle, $haystack, $strict);
        } else {
            throw new InvalidArgumentException('Argument $haystack must be an array or implement Traversable');
        }

        return false;
    }

    /**
     * Checks whether a variable is an array or [[\Traversable]].
     *
     * This method does the same as the PHP function [is_array()](http://php.net/manual/en/function.is-array.php)
     * but additionally works on objects that implement the [[\Traversable]] interface.
     *
     * @param mixed $var The variable being evaluated.
     *
     * @return boolean whether $var is array-like
     * @see   http://php.net/manual/en/function.is_array.php
     */
    public static function isTraversable($var): bool
    {
        return is_array($var) || $var instanceof Traversable;
    }

    /**
     * Checks whether an array or [[\Traversable]] is a subset of another array or [[\Traversable]].
     *
     * This method will return `true`, if all elements of `$needles` are contained in
     * `$haystack`. If at least one element is missing, `false` will be returned.
     *
     * @param array|Traversable $needles  The values that must **all** be in `$haystack`.
     * @param array|Traversable $haystack The set of value to search.
     * @param boolean           $strict   Whether to enable strict (`===`) comparison.
     *
     * @return boolean `true` if `$needles` is a subset of `$haystack`, `false` otherwise.
     * @throws InvalidArgumentException if `$haystack` or `$needles` is neither traversable nor an array.
     */
    public static function isSubset($needles, $haystack, $strict = false): ?bool
    {
        if (is_array($needles) || $needles instanceof Traversable) {
            foreach ($needles as $needle) {
                if (!static::isIn($needle, $haystack, $strict)) {
                    return false;
                }
            }

            return true;
        }

        throw new InvalidArgumentException('Argument $needles must be an array or implement Traversable');
    }

    /**
     * Filters array according to rules specified.
     *
     * For example:
     * ```php
     * $array = [
     *     'A' => [1, 2],
     *     'B' => [
     *         'C' => 1,
     *         'D' => 2,
     *     ],
     *     'E' => 1,
     * ];
     *
     * $result = \Swoft\Helper\ArrayHelper::Filter($array, ['A']);
     * // $result will be:
     * // [
     * //     'A' => [1, 2],
     * // ]
     *
     * $result = \Swoft\Helper\ArrayHelper::Filter($array, ['A', 'B.C']);
     * // $result will be:
     * // [
     * //     'A' => [1, 2],
     * //     'B' => ['C' => 1],
     * // ]
     * ```
     *
     * $result = \Swoft\Helper\ArrayHelper::Filter($array, ['B', '!B.C']);
     * // $result will be:
     * // [
     * //     'B' => ['D' => 2],
     * // ]
     * ```
     *
     * @param array $array   Source array
     * @param array $filters Rules that define array keys which should be left or removed from results.
     *                       Each rule is:
     *                       - `var` - `$array['var']` will be left in result.
     *                       - `var.key` = only `$array['var']['key'] will be left in result.
     *                       - `!var.key` = `$array['var']['key'] will be removed from result.
     *
     * @return array Filtered array
     */
    public static function filter($array, $filters): array
    {
        $result        = [];
        $forbiddenVars = [];

        foreach ($filters as $var) {
            $keys      = explode('.', $var);
            $globalKey = $keys[0];
            $localKey  = $keys[1] ?? null;

            if ($globalKey[0] === '!') {
                $forbiddenVars[] = [
                    substr($globalKey, 1),
                    $localKey,
                ];
                continue;
            }

            if (empty($array[$globalKey])) {
                continue;
            }
            if ($localKey === null) {
                $result[$globalKey] = $array[$globalKey];
                continue;
            }
            if (!isset($array[$globalKey][$localKey])) {
                continue;
            }
            if (!array_key_exists($globalKey, $result)) {
                $result[$globalKey] = [];
            }
            $result[$globalKey][$localKey] = $array[$globalKey][$localKey];
        }

        foreach ($forbiddenVars as $var) {
            [$globalKey, $localKey] = $var;
            if (array_key_exists($globalKey, $result)) {
                unset($result[$globalKey][$localKey]);
            }
        }

        return $result;
    }

    /**
     * Determine whether the given value is array accessible.
     *
     * @param mixed $value
     *
     * @return bool
     */
    public static function accessible($value): bool
    {
        return is_array($value) || $value instanceof ArrayAccess;
    }

    /**
     * Determine if the given key exists in the provided array.
     *
     * @param ArrayAccess|array $array
     * @param string|int        $key
     *
     * @return bool
     */
    public static function exists($array, $key): bool
    {
        if (is_array($array)) {
            return array_key_exists($key, $array);
        }

        return $array->offsetExists($key);
    }

    /**
     * Get an item from an array using "dot" notation.
     *
     * @param ArrayAccess|array $array
     * @param string|int        $key
     * @param mixed             $default
     *
     * @return mixed
     */
    public static function get($array, $key = null, $default = null)
    {
        if ($array instanceof stdClass) {
            $array = (array)$array;
        }

        if (null === $key) {
            return $array;
        }

        if (isset($array[$key])) {
            return $array[$key];
        }

        // Fix: If is int, stop continue find.
        if (!is_string($key)) {
            return $default;
        }

        foreach (explode('.', $key) as $segment) {
            if (static::accessible($array) && static::exists($array, $segment)) {
                $array = $array[$segment];
            } else {
                return value($default);
            }
        }

        return $array;
    }

    /**
     * Check if an item exists in an array using "dot" notation.
     *
     * @param ArrayAccess|array $array
     * @param string            $key
     *
     * @return bool
     */
    public static function has($array, $key): bool
    {
        if (empty($array) || null === $key) {
            return false;
        }

        if (array_key_exists($key, $array)) {
            return true;
        }

        foreach (explode('.', $key) as $segment) {
            if ((is_array($array) && array_key_exists($segment,
                        $array)) || ($array instanceof ArrayAccess && $array->offsetExists($segment))
            ) {
                $array = $array[$segment];
            } else {
                return false;
            }
        }

        return true;
    }

    /**
     * Set an array item to a given value using "dot" notation.
     * If no key is given to the method, the entire array will be replaced.
     *
     * @param array  $array
     * @param string $key
     * @param mixed  $value
     *
     * @return array
     */
    public static function set(&$array, $key, $value): array
    {
        if (null === $key) {
            return $array = $value;
        }

        $keys = explode('.', $key);

        while (count($keys) > 1) {
            $key = array_shift($keys);

            // If the key doesn't exist at this depth, we will just create an empty array
            // to hold the next value, allowing us to create the arrays to hold final
            // values at the correct depth. Then we'll keep digging into the array.
            if (!isset($array[$key]) || !is_array($array[$key])) {
                $array[$key] = [];
            }

            $array = &$array[$key];
        }

        $array[array_shift($keys)] = $value;

        return $array;
    }

    /**
     * Insert one array to another array
     *
     * @param array $array
     * @param int   $index
     * @param array $insert
     */
    public static function insert(array &$array, int $index, ...$insert): void
    {
        $firstArray = array_splice($array, 0, $index);
        $array      = array_merge($firstArray, $insert, $array);
    }

    /**
     * If the given value is not an array and not null, wrap it in one.
     *
     * @param mixed $value
     *
     * @return array
     */
    public static function wrap($value): array
    {
        if ($value === null) {
            return [];
        }

        return is_array($value) ? $value : [$value];
    }

    /**
     * @param mixed $value
     *
     * @return bool
     */
    public static function isArrayable($value): bool
    {
        return is_array($value) || $value instanceof Arrayable;
    }

    /**
     * Flatten a multi-dimensional array into a single level.
     *
     * @param array $array
     * @param int   $depth
     *
     * @return array
     */
    public static function flatten(array $array, int $depth = PHP_INT_MAX): array
    {
        $result = [];

        foreach ($array as $item) {
            $item = $item instanceof Collection ? $item->all() : $item;

            if (!is_array($item)) {
                $result[] = $item;
            } elseif ($depth === 1) {
                $result = array_merge($result, array_values($item));
            } else {
                $result = array_merge($result, static::flatten($item, $depth - 1));
            }
        }

        return $result;
    }

    /**
     * find similar text from an array|Iterator
     *
     * @param string         $need
     * @param Iterator|array $iterator
     * @param int            $similarPercent
     *
     * @return array
     */
    public static function findSimilar(string $need, $iterator, int $similarPercent = 45): array
    {
        if (!$need) {
            return [];
        }

        // find similar command names by similar_text()
        $similar = [];

        foreach ($iterator as $name) {
            similar_text($need, $name, $percent);

            if ($similarPercent <= (int)$percent) {
                $similar[] = $name;
            }
        }

        return $similar;
    }

    /**
     * get key Max Width
     *
     * @param array $data
     *     [
     *     'key1'      => 'value1',
     *     'key2-test' => 'value2',
     *     ]
     * @param bool  $expectInt
     *
     * @return int
     */
    public static function getKeyMaxWidth(array $data, bool $expectInt = false): int
    {
        $keyMaxWidth = 0;

        foreach ($data as $key => $value) {
            // key is not a integer
            if (!$expectInt || !is_numeric($key)) {
                $width       = mb_strlen((string)$key, 'UTF-8');
                $keyMaxWidth = $width > $keyMaxWidth ? $width : $keyMaxWidth;
            }
        }

        return $keyMaxWidth;
    }

    /**
     * Return the first element in an array passing a given truth test.
     *
     * @param array         $array
     * @param callable|null $callback
     * @param mixed         $default
     *
     * @return mixed
     */
    public static function first($array, callable $callback = null, $default = null)
    {
        if ($callback === null) {
            if (empty($array)) {
                return value($default);
            }

            foreach ($array as $item) {
                return $item;
            }
        }

        foreach ($array as $key => $value) {
            if (call_user_func($callback, $value, $key)) {
                return $value;
            }
        }

        return value($default);
    }

    /**
     * Filter the array using the given callback.
     *
     * @param array    $array
     * @param callable $callback
     *
     * @return array
     */
    public static function where($array, callable $callback)
    {
        return array_filter($array, $callback, ARRAY_FILTER_USE_BOTH);
    }

    /**
     * Convert the array into a query string.
     *
     * @param array $array
     *
     * @return string
     */
    public static function query(array $array): string
    {
        return http_build_query($array, '', '&', PHP_QUERY_RFC3986);
    }

    /**
     * Get a subset of the items from the given array.
     *
     * @param array $array
     * @param array $keys
     *
     * @return array
     */
    public static function only(array $array, array $keys): array
    {
        return array_intersect_key($array, array_flip((array)$keys));
    }

    /**
     * Return the last element in an array passing a given truth test.
     *
     * @param array         $array
     * @param callable|null $callback
     * @param mixed         $default
     *
     * @return mixed
     */
    public static function last($array, callable $callback = null, $default = null)
    {
        if (is_null($callback)) {
            return empty($array) ? value($default) : end($array);
        }

        return static::first(array_reverse($array, true), $callback, $default);
    }

    /**
     * Pluck an array of values from an array.
     *
     * @param array             $array
     * @param string|array      $value
     * @param string|array|null $key
     *
     * @return array
     */
    public static function pluck($array, $value, $key = null)
    {
        $results = [];

        foreach ($array as $item) {
            $itemValue = static::get($item, $value);

            // If the key is "null", we will just append the value to the array and keep
            // looping. Otherwise we will key the array using the value of the key we
            // received from the developer. Then we'll return the final array form.
            if (is_null($key)) {
                $results[] = $itemValue;
            } else {
                $itemKey = static::get($item, $key);

                if (is_object($itemKey) && method_exists($itemKey, '__toString')) {
                    $itemKey = (string)$itemKey;
                }

                $results[$itemKey] = $itemValue;
            }
        }

        return $results;
    }

    /**
     * Collapse an array of arrays into a single array.
     *
     * @param array $array
     *
     * @return array
     */
    public static function collapse($array)
    {
        $results = [];

        foreach ($array as $values) {
            if ($values instanceof Collection) {
                $values = $values->all();
            } elseif (!is_array($values)) {
                continue;
            }

            $results = array_merge($results, $values);
        }

        return $results;
    }

    /**
     * Cross join the given arrays, returning all possible permutations.
     *
     * @param array ...$arrays
     *
     * @return array
     */
    public static function crossJoin(...$arrays)
    {
        $results = [[]];

        foreach ($arrays as $index => $array) {
            $append = [];

            foreach ($results as $product) {
                foreach ($array as $item) {
                    $product[$index] = $item;

                    $append[] = $product;
                }
            }

            $results = $append;
        }

        return $results;
    }

    /**
     * Push an item onto the beginning of an array.
     *
     * @param array $array
     * @param mixed $value
     * @param mixed $key
     *
     * @return array
     */
    public static function prepend($array, $value, $key = null)
    {
        if (is_null($key)) {
            array_unshift($array, $value);
        } else {
            $array = [$key => $value] + $array;
        }

        return $array;
    }

    /**
     * Get one or a specified number of random values from an array.
     *
     * @param array    $array
     * @param int|null $number
     *
     * @return mixed
     *
     * @throws InvalidArgumentException
     */
    public static function random($array, $number = null)
    {
        $requested = is_null($number) ? 1 : $number;

        $count = count($array);

        if ($requested > $count) {
            throw new InvalidArgumentException("You requested {$requested} items, but there are only {$count} items available.");
        }

        if (is_null($number)) {
            return $array[array_rand($array)];
        }

        if ((int)$number === 0) {
            return [];
        }

        $keys = array_rand($array, $number);

        $results = [];

        foreach ((array)$keys as $key) {
            $results[] = $array[$key];
        }

        return $results;
    }

    /**
     * array to string
     *
     * @param array  $array
     * @param string $glue
     *
     * @return string
     */
    public static function toString(array $array, string $glue = '_'): string
    {
        return implode($glue, $array);
    }

    /**
     * Shuffle the given array and return the result.
     *
     * @param array    $array
     * @param int|null $seed
     *
     * @return array
     */
    public static function shuffle($array, $seed = null)
    {
        if (is_null($seed)) {
            shuffle($array);
        } else {
            mt_srand($seed);
            shuffle($array);
            mt_srand();
        }

        return $array;
    }
}
?>
--
3、目录函数
目录函数包括创建、遍历目录内容等，需引入 Swoft\Stdlib\Helper\Dir 或 Swoft\Stdlib\Helper\DirHelper 或 Swoft\Stdlib\Helper\DirectoryHelper。目录函数继承自文件系统函数，详情参阅：DirectoryHelper.php 文件( https://github.com/swoft-cloud/swoft-stdlib/blob/master/src/Helper/DirectoryHelper.php )。
<?php declare(strict_types=1);

namespace Swoft\Stdlib\Helper;

use DirectoryIterator;
use FilesystemIterator;
use InvalidArgumentException;
use IteratorIterator;
use RecursiveCallbackFilterIterator;
use RecursiveDirectoryIterator;
use RecursiveIteratorIterator;
use RuntimeException;
use SplFileInfo;
use function file_exists;
use function is_dir;
use function mkdir;
use function sprintf;
use function strpos;
use function substr;

/**
 * Directory helper
 *
 * @since 2.0
 */
class DirectoryHelper extends FSHelper
{
    /**
     * Create directory with recursive
     *
     * @param string  $dir
     * @param integer $mode
     *
     * @return void
     */
    public static function make(string $dir, int $mode = 0755): void
    {
        if (!file_exists($dir) && !mkdir($dir, $mode, true) && !is_dir($dir)) {
            throw new RuntimeException(sprintf('Directory "%s" was not created', $dir));
        }
    }

    /**
     * Directory recursive iterator
     *
     * @param string $path
     * @param int    $mode
     * @param int    $flags
     *
     * @return RecursiveIteratorIterator
     */
    public static function recursiveIterator(
        string $path,
        int $mode = RecursiveIteratorIterator::LEAVES_ONLY,
        int $flags = 0
    ): RecursiveIteratorIterator {
        if (empty($path) || !file_exists($path)) {
            throw new InvalidArgumentException('File path is not exist! Path: ' . $path);
        }

        $directoryIterator = new RecursiveDirectoryIterator($path);

        return new RecursiveIteratorIterator($directoryIterator, $mode, $flags);
    }

    /**
     * Directory iterator
     *
     * @param string $path
     *
     * @return IteratorIterator
     */
    public static function iterator(string $path): IteratorIterator
    {
        if (empty($path) || !file_exists($path)) {
            throw new InvalidArgumentException('File path is not exist! Path: ' . $path);
        }

        $directoryIterator = new DirectoryIterator($path);

        return new IteratorIterator($directoryIterator);
    }


    /**
     * Find all php files in the dir-path.
     *
     * @param string $dirPath
     *
     * @return RecursiveIteratorIterator
     */
    public static function phpFilesIterator(string $dirPath): RecursiveIteratorIterator
    {
        $filter = function (SplFileInfo $f): bool {
            $name = $f->getFilename();

            // Skip hidden files and directories.
            if (strpos($name, '.') === 0) {
                return false;
            }

            // Goon read sub-dir
            if ($f->isDir()) {
                return true;
            }

            // Only find php file
            return $f->isFile() && substr($name, -4) === '.php';
        };

        return self::filterIterator($dirPath, $filter);
    }

    /**
     * Directory iterator but support filter files.
     *
     * @param string   $dirPath
     * @param callable $filter
     *      eg: only find php file
     *      $filter = function (\SplFileInfo $f): bool {
     *      $name = $f->getFilename();
     *
     *       // Skip hidden files and directories.
     *      if (\strpos($name, '.') === 0) {
     *          return false;
     *      }
     *
     *      // go on read sub-dir
     *      if ($f->isDir()) {
     *          return true;
     *      }
     *
     *      // php file
     *      return $f->isFile() && \substr($name, -4) === '.php';
     * }
     * @param int      $flags
     *
     * @return RecursiveIteratorIterator
     * @throws InvalidArgumentException
     */
    public static function filterIterator(
        string $dirPath,
        callable $filter,
        $flags = FilesystemIterator::KEY_AS_PATHNAME | FilesystemIterator::CURRENT_AS_FILEINFO
    ): RecursiveIteratorIterator {
        if (!$dirPath || !file_exists($dirPath)) {
            throw new InvalidArgumentException('Please provide a exists source directory. Path:' . $dirPath);
        }

        $directory      = new RecursiveDirectoryIterator($dirPath, $flags);
        $filterIterator = new RecursiveCallbackFilterIterator($directory, $filter);

        return new RecursiveIteratorIterator($filterIterator);
    }
}
?>
--
4、环境函数
环境函数主要用于获取当前运行环境，其中包括：
use Swoft\Stdlib\Helper\EnvHelper;
// 是否运行在 CLI 模式
EnvHelper::isCli();
// 是否运行在 PHP Debug 模式
EnvHelper::isPhpDbg();
// 当前运行环境是否为 Windows
EnvHelper::isWin();
EnvHelper::isWindows();
// 当前运行环境是否为 macOS
EnvHelper::isMac();
--
5、文件函数
se Swoft\Stdlib\Helper\FileHelper;
$fileName = '/opt/file.txt';
// 获取文件后缀，$clearPoint 为 true 时不返回带“.”的后缀
FileHelper::getSuffix($fileName, true);
// getExt 方法为 getExtension 方法别名，该方法与 getSuffix 方法作用相同
FileHelper::getExt($fileName, true);
FileHelper::getExtension($fileName, true);
// 获取文件 MIME 类型，文本会返回 text/plain
FileHelper::mimeType($fileName);
--
6、文件系统函数
文件系统函数需引入 Swoft\Stdlib\Helper\FSHelper。详情参阅：FSHelper 文件( https://github.com/swoft-cloud/swoft-stdlib/blob/master/src/Helper/FSHelper.php )。

<?php

namespace Swoft\Stdlib\Helper;

use function array_pop;
use function explode;
use function implode;
use function preg_match;
use function preg_replace;
use function str_replace;
use function strpos;
use function substr;
use const DIRECTORY_SEPARATOR;

/**
 * Class FSHelper - file system helper
 *
 * @since 2.0
 */
class FSHelper
{
    /**
     * @param string $path
     *
     * @return string
     */
    public static function formatPath(string $path): string
    {
        if (DIRECTORY_SEPARATOR === '\\') {
            return str_replace('\\', '/', $path);
        }

        return $path;
    }

    /**
     * @param $path
     *
     * @return bool
     */
    public static function isAbsPath(string $path): bool
    {
        if (!$path) {
            return false;
        }

        if (strpos($path, '/') === 0 // linux/mac
            || 1 === preg_match('#^[a-z]:[\/|\\\]{1}.+#i', $path) // windows
        ) {
            return true;
        }

        return false;
    }

    /**
     * @param string $path e.g phar://E:/workenv/xxx/yyy/app.phar/web
     *
     * @return string
     */
    public function clearPharPath(string $path): string
    {
        if (strpos($path, 'phar://') === 0) {
            $path = (string)substr($path, 7);

            if (strpos($path, '.phar')) {
                return preg_replace('//[\w-]+\.phar/', '', $path);
            }
        }

        return $path;
    }

    /**
     * Returns canonicalized absolute pathname
     * Convert 'this/is/../a/./test/.///is' to 'this/a/test/is'
     *
     * @param string $path
     * @param bool   $filter
     *
     * @return string
     */
    public static function conv2abs(string $path, bool $filter = true): string
    {
        $path = str_replace('\\', '/', $path);

        if (strpos($path, '..') === false) {
            return $path;
        }

        $first = '';
        $parts = explode('/', $path);
        if ($filter) {
            $first = $path[0] === '/' ? '/' : '';
            $parts = array_filter($parts, 'strlen');
        }

        $absolutes = [];
        foreach ($parts as $part) {
            if ('.' === $part) {
                continue;
            }

            if ('..' === $part) {
                array_pop($absolutes);
            } else {
                $absolutes[] = $part;
            }
        }

        return $first . implode('/', $absolutes);
    }
}
?>
--
7、对象函数
对象函数用于相关对象操作，其中包括：
use Swoft\Stdlib\Helper\ObjectHelper;
// 获取对象哈希值
ObjectHelper::hash($object);
// 向对象设置或新增属性
ObjectHelper::init($object, $options = ['name' => 'Swoft']);
// 解析参数类型
ObjectHelper::parseParamType('int', $object);
// 获取属性基本数据类型
ObjectHelper::getPropertyBaseType($property);
// 获取数据类型默认值
ObjectHelper::getDefaultValue('int');
--
8、PHP 助手函数
PHP 助手函数扩展了一些原生函数，需引入 Swoft\Stdlib\Helper\PhpHelper。详情参阅：PhpHelper.php ( https://github.com/swoft-cloud/swoft-stdlib/blob/master/src/Helper/PhpHelper.php )文件。
<?php declare(strict_types=1);

namespace Swoft\Stdlib\Helper;

use Throwable;
use function explode;
use function function_exists;
use function get_class;
use function is_array;
use function is_object;
use function is_string;
use function method_exists;
use function ob_get_clean;
use function ob_start;
use function preg_replace;
use function serialize;
use function sprintf;
use function strpos;
use function unserialize;
use function var_dump;
use function var_export;
use const PHP_EOL;

/**
 * Php helper
 *
 * @since 2.0
 */
class PhpHelper
{
    /**
     * Call by callback
     *
     * @param callable|array $cb   callback
     * @param array          $args arguments
     *
     * @return mixed
     */
    public static function call($cb, ...$args)
    {
        if (is_string($cb)) {
            // className::method
            if (strpos($cb, '::') > 0) {
                $cb = explode('::', $cb, 2);
                // function
            } elseif (function_exists($cb)) {
                return $cb(...$args);
            }
        } elseif (is_object($cb) && method_exists($cb, '__invoke')) {
            return $cb(...$args);
        }

        if (is_array($cb)) {
            [$obj, $mhd] = $cb;

            return is_object($obj) ? $obj->$mhd(...$args) : $obj::$mhd(...$args);
        }

        return $cb(...$args);
    }

    /**
     * Call by callback
     *
     * @param callable $cb
     * @param array    $args
     *
     * @return mixed
     */
    public static function callByArray($cb, array $args = [])
    {
        return self::call($cb, ...$args);
    }

    /**
     * @param $data
     *
     * @return string
     */
    public static function serialize($data): string
    {
        return serialize($data);
    }

    /**
     * @param string $data
     * @param array  $opts
     *
     * @return array|mixed
     */
    public static function unserialize(string $data, array $opts = ['allowed_classes' => false])
    {
        return unserialize($data, $opts);
    }

    /**
     * dump vars
     *
     * @param array ...$args
     *
     * @return string
     */
    public static function dumpVars(...$args): string
    {
        ob_start();
        var_dump(...$args);
        $string = ob_get_clean();

        return preg_replace("/=>\n\s+/", '=> ', $string);
    }

    /**
     * print vars
     *
     * @param array ...$args
     *
     * @return string
     */
    public static function printVars(...$args): string
    {
        $string = '';

        foreach ($args as $arg) {
            $string .= print_r($arg, 1) . PHP_EOL;
        }

        return preg_replace("/Array\n\s+\(/", 'Array (', $string);
    }

    /**
     * @param mixed $var
     *
     * @return string
     */
    public static function exportVar($var): string
    {
        $string = var_export($var, true);

        return preg_replace('/=>\s+\n\s+array \(/', '=> array (', $string);
    }

    /**
     * @param Throwable $e
     * @param string    $title
     * @param bool      $debug
     *
     * @return string
     */
    public static function exceptionToString(Throwable $e, string $title = '', bool $debug = false): string
    {
        $errClass = get_class($e);

        if (false === $debug) {
            return sprintf('%s %s(code:%d) %s', $title, $errClass, $e->getCode(), $e->getMessage());
        }

        return sprintf('%s%s(code:%d): %s At %s line %d', $title ? $title . ' - ' : '', $errClass, $e->getCode(),
            $e->getMessage(), $e->getFile(), $e->getLine());
    }

    /**
     * @param Throwable $e
     * @param bool      $debug
     *
     * @return array
     */
    public static function exceptionToArray(Throwable $e, bool $debug = false): array
    {
        if (false === $debug) {
            return [
                'code'  => $e->getCode(),
                'error' => $e->getMessage(),
            ];
        }

        return [
            'code'  => $e->getCode(),
            'error' => sprintf('(%s) %s', get_class($e), $e->getMessage()),
            'file'  => sprintf('At %s line %d', $e->getFile(), $e->getLine()),
            'trace' => $e->getTraceAsString(),
        ];
    }
}
?>
--
9、字符串函数
字符串函数内容过多，需引入 Swoft\Stdlib\Helper\Str 或 Swoft\Stdlib\Helper\StringHelper。详情参阅：StringHelper.php ( https://github.com/swoft-cloud/swoft-stdlib/blob/master/src/Helper/StringHelper.php )文件。
<?php declare(strict_types=1);

namespace Swoft\Stdlib\Helper;

use Swoft\Stdlib\Concern\RandomStringTrait;
use function explode;
use function is_string;
use function lcfirst;
use function mb_convert_case;
use function mb_strlen;
use function mb_strtoupper;
use function preg_match;
use function preg_replace;
use function str_pad;
use function str_repeat;
use function str_replace;
use function strlen;
use function strpos;
use function strrpos;
use function substr;
use function substr_replace;
use function trim;
use const STR_PAD_LEFT;
use const STR_PAD_RIGHT;

/**
 * String helper
 *
 * @since 2.0
 */
class StringHelper
{
    use RandomStringTrait;

    /**
     * The cache of snake-cased words.
     *
     * @var array
     */
    protected static $snakeCache = [];

    /**
     * The cache of camel-cased words.
     *
     * @var array
     */
    protected static $camelCache = [];

    /**
     * The cache of studly-cased words.
     *
     * @var array
     */
    protected static $studlyCache = [];

    /**
     * Transliterate a UTF-8 value to ASCII.
     *
     * @param string $value
     *
     * @return string
     */
    public static function ascii($value): string
    {
        foreach (StringChars::getChars() as $key => $val) {
            $value = str_replace($val, $key, $value);
        }

        return preg_replace('/[^\x20-\x7E]/u', '', $value);
    }

    /**
     * Convert a value to camel case.
     *
     * @param string $value
     * @param bool   $lcfirst
     *
     * @return string
     */
    public static function camel($value, bool $lcfirst = true): string
    {
        if (isset(static::$camelCache[$value])) {
            return static::$camelCache[$value];
        }

        return static::$camelCache[$value] = ($lcfirst ? lcfirst(static::studly($value)) : static::studly($value));
    }

    /**
     * @param string $string
     * @param string $delimiter
     * @param int    $limit
     *
     * @return array
     */
    public static function toArray(string $string, string $delimiter = ',', int $limit = 0): array
    {
        $string = trim($string, "$delimiter ");
        if ($string === '') {
            return [];
        }

        $values  = [];
        $rawList = $limit < 1 ? explode($delimiter, $string) : explode($delimiter, $string, $limit);

        foreach ($rawList as $val) {
            if (($val = trim($val)) !== '') {
                $values[] = $val;
            }
        }

        return $values;
    }

    /**
     * @param string $str
     * @param string $separator
     * @param int    $limit
     *
     * @return array
     */
    public static function explode(string $str, string $separator = ',', int $limit = 0): array
    {
        return static::toArray($str, $separator, $limit);
    }

    /**
     * Determine if a given string contains a given substring.
     *
     * @param string       $haystack
     * @param string|array $needles
     *
     * @return bool
     */
    public static function contains(string $haystack, $needles): bool
    {
        foreach ((array)$needles as $needle) {
            if ($needle !== '' && strpos($haystack, $needle) !== false) {
                return true;
            }
        }

        return false;
    }

    /**
     * Determine if a given string ends with a given substring.
     *
     * @param string       $haystack
     * @param string|array $needles
     *
     * @return bool
     */
    public static function endsWith(string $haystack, $needles): bool
    {
        foreach ((array)$needles as $needle) {
            if ((string)$needle === substr($haystack, -strlen($needle))) {
                return true;
            }
        }

        return false;
    }

    /**
     * @param string $str
     *
     * @return string
     */
    public static function firstLine(string $str): string
    {
        if (!$str = trim($str)) {
            return '';
        }

        if (strpos($str, "\n") > 0) {
            return explode("\n", $str)[0];
        }

        return $str;
    }

    /**
     * Cap a string with a single instance of a given value.
     *
     * @param string $value
     * @param string $cap
     *
     * @return string
     */
    public static function finish($value, $cap): string
    {
        $quoted = preg_quote($cap, '/');

        return preg_replace('/(?:' . $quoted . ')+$/', '', $value) . $cap;
    }

    /**
     * Determine if a given string matches a given pattern.
     *
     * @param string $pattern
     * @param string $value
     *
     * @return bool
     */
    public static function is(string $pattern, string $value): bool
    {
        if ($pattern === $value) {
            return true;
        }

        $pattern = preg_quote($pattern, '#');

        // Asterisks are translated into zero-or-more regular expression wildcards
        // to make it convenient to check if the strings starts with the given
        // pattern such as "library/*", making any string check convenient.
        $pattern = str_replace('\*', '.*', $pattern);

        return (bool)preg_match('#^' . $pattern . '\z#', $value);
    }

    /**
     * Return the length of the given string.
     *
     * @param string|int  $value
     * @param string $encode
     *
     * @return int
     */
    public static function length($value, string $encode = 'utf-8'): int
    {
        return mb_strlen((string)$value, $encode);
    }

    /**
     * Return the length of the given string.
     *
     * @param string|int $value
     * @param string|null $encode
     *
     * @return int
     */
    public static function len($value, string $encode = 'utf-8'): int
    {
        return mb_strlen((string)$value, $encode);
    }

    /**
     * @param string|int $string
     * @param int|float $padLen
     * @param string $padStr
     * @param int    $padType
     *
     * @return string
     */
    public static function pad($string, $padLen, string $padStr = ' ', int $padType = STR_PAD_RIGHT): string
    {
        $string = (string)$string;

        return $padLen > 0 ? str_pad($string, (int)$padLen, $padStr, $padType) : $string;
    }

    /**
     * @param string|int $string
     * @param int    $padLen
     * @param string $padStr
     *
     * @return string
     */
    public static function padLeft($string, int $padLen, string $padStr = ' '): string
    {
        $string = (string)$string;

        return $padLen > 0 ? str_pad($string, $padLen, $padStr, STR_PAD_LEFT) : $string;
    }

    /**
     * @param string|int $string
     * @param int    $padLen
     * @param string $padStr
     *
     * @return string
     */
    public static function padRight($string, int $padLen, string $padStr = ' '): string
    {
        $string = (string)$string;

        return $padLen > 0 ? str_pad($string, $padLen, $padStr) : $string;
    }

    /**
     * @param string|int $string
     * @param int $length
     *
     * @return string
     */
    public static function repeat($string, $length): string
    {
        return str_repeat((string)$string, (int)$length);
    }

    /**
     * Limit the number of characters in a string.
     *
     * @param string $value
     * @param int    $limit
     * @param string $end
     *
     * @return string
     */
    public static function limit($value, $limit = 100, $end = '...'): string
    {
        if (mb_strwidth($value, 'UTF-8') <= $limit) {
            return $value;
        }

        return rtrim(mb_strimwidth($value, 0, $limit, '', 'UTF-8')) . $end;
    }

    /**
     * Convert the given string to lower-case.
     *
     * @param string $value
     *
     * @return string
     */
    public static function lower(string $value): string
    {
        return mb_strtolower($value, 'UTF-8');
    }

    /**
     * Limit the number of words in a string.
     *
     * @param string $value
     * @param int    $words
     * @param string $end
     *
     * @return string
     */
    public static function words($value, $words = 100, $end = '...'): string
    {
        preg_match('/^\s*+(?:\S++\s*+){1,' . $words . '}/u', $value, $matches);

        if (!isset($matches[0]) || strlen($value) === strlen($matches[0])) {
            return $value;
        }

        return rtrim($matches[0]) . $end;
    }

    /**
     * Parse a `Class@method` style callback into class and method.
     *
     * @param string $callback
     * @param string $default
     *
     * @return array
     */
    public static function parseCallback(string $callback, string $default): array
    {
        return static::contains($callback, '@') ? explode('@', $callback, 2) : [$callback, $default];
    }

    /**
     * Compares two strings using a constant-time algorithm.
     * Note: This method will leak length information.
     * Note: Adapted from Symfony\Component\Security\Core\Util\StringUtils.
     *
     * @param string $knownString
     * @param string $userInput
     *
     * @return bool
     * @deprecated since version 5.2. Use hash_equals instead.
     */
    public static function equals(string $knownString, string $userInput): bool
    {
        return hash_equals($knownString, $userInput);
    }

    /**
     * Replace the first occurrence of a given value in the string.
     *
     * @param string $search
     * @param string $replace
     * @param string $subject
     *
     * @return string
     */
    public static function replaceFirst($search, $replace, $subject): string
    {
        $position = strpos($subject, $search);

        if ($position !== false) {
            return substr_replace($subject, $replace, $position, strlen($search));
        }

        return $subject;
    }

    /**
     * Replace the last occurrence of a given value in the string.
     *
     * @param string $search
     * @param string $replace
     * @param string $subject
     *
     * @return string
     */
    public static function replaceLast(string $search, $replace, string $subject): string
    {
        $position = strrpos($subject, $search);

        if ($position !== false) {
            return substr_replace($subject, $replace, $position, strlen($search));
        }

        return $subject;
    }

    /**
     * Convert the given string to upper-case.
     *
     * @param string $value
     *
     * @return string
     */
    public static function upper(string $value): string
    {
        return mb_strtoupper($value, 'UTF-8');
    }

    /**
     * Convert the given string to title case.
     *
     * @param string $value
     *
     * @return string
     */
    public static function title($value): string
    {
        return mb_convert_case($value, MB_CASE_TITLE, 'UTF-8');
    }

    /**
     * Generate a URL friendly "slug" from a given string.
     *
     * @param string $title
     * @param string $separator
     *
     * @return string
     */
    public static function slug(string $title, string $separator = '-'): string
    {
        $title = static::ascii($title);

        // Convert all dashes/underscores into separator
        $flip = $separator === '-' ? '_' : '-';

        $title = preg_replace('![' . preg_quote($flip) . ']+!u', $separator, $title);

        // Remove all characters that are not the separator, letters, numbers, or whitespace.
        $title = preg_replace('![^' . preg_quote($separator) . '\pL\pN\s]+!u', '', mb_strtolower($title));

        // Replace all separator characters and whitespace by a single separator
        $title = preg_replace('![' . preg_quote($separator) . '\s]+!u', $separator, $title);

        return trim($title, $separator);
    }

    /**
     * Convert a string to snake case.
     *
     * @param string $value
     * @param string $delimiter
     *
     * @return string
     */
    public static function snake(string $value, string $delimiter = '_'): string
    {
        $key = $value . $delimiter;

        if (isset(static::$snakeCache[$key])) {
            return static::$snakeCache[$key];
        }

        if (!ctype_lower($value)) {
            $value = preg_replace('/\s+/', '', $value);

            $value = strtolower(preg_replace('/(.)(?=[A-Z])/', '$1' . $delimiter, $value));
        }

        return static::$snakeCache[$key] = $value;
    }

    /**
     * Determine if a given string starts with a given substring.
     *
     * @param string       $haystack
     * @param string|array $needles
     *
     * @return bool
     */
    public static function startsWith(string $haystack, $needles): bool
    {
        foreach ((array)$needles as $needle) {
            if ($needle !== '' && strpos($haystack, $needle) === 0) {
                return true;
            }
        }

        return false;
    }

    /**
     * Convert a value to studly caps case.
     *
     * @param string $value
     *
     * @return string
     */
    public static function studly($value): string
    {
        $key = $value;

        if (isset(static::$studlyCache[$key])) {
            return static::$studlyCache[$key];
        }

        $value = ucwords(str_replace(['-', '_'], ' ', $value));

        return static::$studlyCache[$key] = str_replace(' ', '', $value);
    }

    /**
     * Returns the portion of string specified by the start and length parameters.
     *
     * @param string   $string
     * @param int      $start
     * @param int|null $length
     *
     * @return string
     */
    public static function substr(string $string, $start, $length = null): string
    {
        return mb_substr($string, $start, $length, 'UTF-8');
    }

    /**
     * Make a string's first character uppercase.
     *
     * @param string $string
     *
     * @return string
     */
    public static function ucfirst(string $string): string
    {
        return static::upper(static::substr($string, 0, 1)) . static::substr($string, 1);
    }

    public static function trim($str, $prefix = '', $suffix = ''): void
    {
    }

    public static function strSplit($str, $splitLength = 1)
    {
        $splitLength = (int)$splitLength;

        if (self::isAscii($str)) {
            return str_split($str, $splitLength);
        }

        if ($splitLength < 1) {
            return false;
        }

        if (mb_strlen($str) <= $splitLength) {
            return [$str];
        }
        preg_match_all('/.{' . $splitLength . '}|[^\x00]{1,' . $splitLength . '}$/us', $str, $matches);
        return $matches[0];
    }

    /**
     * @param string $str
     *
     * @return bool
     */
    public static function isAscii($str): bool
    {
        return is_string($str) && !preg_match('/[^\x00-\x7F]/S', $str);
    }

    /**
     * Get class name without suffix. eg: HomeController -> home
     *
     * @param string $class  full class name, with namespace.
     * @param string $suffix class suffix
     *
     * @return string
     */
    public static function getClassName(string $class, string $suffix): string
    {
        if (empty($suffix)) {
            return $class;
        }

        // \\(\w+)Helper$
        if (strpos($class, $suffix) > 0) {
            $regex = '/\\\(\w+)' . $suffix . '$/';
            $ok    = preg_match($regex, $class, $match);
        } else {
            $ok    = true;
            $match = [1 => $class];
        }

        return $ok ? lcfirst($match[1]) : '';
    }

    /**
     * @param string $path
     *
     * @return string
     */
    public static function formatPath(string $path): string
    {
        $path = '/' . trim($path, '/ ');

        return $path ?: '/';
    }

    /**
     * @param string $path
     *
     * @return string
     */
    public static function rmPharPrefix(string $path): string
    {
        if (0 === strpos($path, 'phar://')) {
            return preg_replace('/[\w-]+\.phar\//', '', substr($path, 7));
        }

        return $path;
    }

    /**
     * @param array|string $queryData
     *
     * @return string
     */
    public static function buildQuery($queryData): string
    {
        // is string
        if (is_string($queryData)) {
            return $queryData;
        }

        // array: k-v map
        return preg_replace('/%5B(?:\d|[1-9]\d+)%5D=/', '=', http_build_query($queryData));
    }
}
?>
--
10、系统函数
系统函数用于运行命令及获取系统相关信息等操作，需引入 Swoft\Stdlib\Helper\Sys 或 Swoft\Stdlib\Helper\SystemHelper。详情参阅：SystemHelper.php ( https://github.com/swoft-cloud/swoft-stdlib/blob/master/src/Helper/SystemHelper.php )文件。
<?php declare(strict_types=1);

namespace Swoft\Stdlib\Helper;

use RuntimeException;
use function chdir;
use function exec;
use function fclose;
use function function_exists;
use function getcwd;
use function getmyuid;
use function implode;
use function is_resource;
use function ob_start;
use function preg_match;
use function preg_replace;
use function proc_close;
use function proc_open;
use function shell_exec;
use function stream_get_contents;
use function sys_get_temp_dir;
use function system;
use function trim;

/**
 * Class SystemHelper
 *
 * @since 2.0
 */
class SystemHelper extends EnvHelper
{
    /**
     * Set cli process title
     *
     * @param string $title
     *
     * @return bool
     */
    public static function setProcessTitle(string $title): bool
    {
        if (self::isMac() || self::isCygwin()) {
            return false;
        }

        if (function_exists('cli_set_process_title')) {
            return @cli_set_process_title($title);
        }

        return true;
    }

    /**
     * Run a command. It is support windows
     *
     * @param string      $command
     * @param string|null $cwd
     *
     * @return array [$code, $output, $error]
     * @throws RuntimeException
     */
    public static function run(string $command, string $cwd = null): array
    {
        $descriptors = [
            0 => ['pipe', 'r'], // stdin - read channel
            1 => ['pipe', 'w'], // stdout - write channel
            2 => ['pipe', 'w'], // stdout - error channel
            3 => ['pipe', 'r'], // stdin - This is the pipe we can feed the password into
        ];

        $pipes   = [];
        $process = proc_open($command, $descriptors, $pipes, $cwd);

        if (!is_resource($process)) {
            throw new RuntimeException("Can't open resource with proc_open.");
        }

        // Nothing to push to input.
        fclose($pipes[0]);

        $output = stream_get_contents($pipes[1]);
        fclose($pipes[1]);

        $error = stream_get_contents($pipes[2]);
        fclose($pipes[2]);

        // TODO: Write passphrase in pipes[3].
        fclose($pipes[3]);

        // Close all pipes before proc_close! $code === 0 is success.
        $code = proc_close($process);

        return [$code, $output, $error];
    }

    /**
     * Method to execute a command in the sys
     * Uses :
     * - system
     * - exec
     * - shell_exec
     *
     * @param string      $command
     * @param bool        $returnStatus
     * @param string|null $cwd
     *
     * @return array|string
     */
    public static function execute(string $command, bool $returnStatus = true, string $cwd = null)
    {
        $exitStatus = 1;

        if ($cwd) {
            chdir($cwd);
        }

        // system
        if (function_exists('system')) {
            ob_start();
            system($command, $exitStatus);
            $output = ob_get_clean();

            //exec
        } elseif (function_exists('exec')) {
            exec($command, $output, $exitStatus);
            $output = implode("\n", $output);

            //shell_exec
        } elseif (function_exists('shell_exec')) {
            $output = shell_exec($command);
        } else {
            $output     = 'Command execution not possible on this system';
            $exitStatus = 0;
        }

        if ($returnStatus) {
            return [
                'output' => trim($output),
                'status' => $exitStatus
            ];
        }

        return trim($output);
    }

    /**
     * Get unix user of current process.
     *
     * @return array
     */
    public static function getCurrentUser(): array
    {
        if (function_exists('posix_getpwuid')) {
            /** @noinspection PhpComposerExtensionStubsInspection */
            return posix_getpwuid(getmyuid());
        }

        return [];
    }

    /**
     * @return string
     */
    public static function tempDir(): string
    {
        return self::getTempDir();
    }

    /**
     * @return string
     */
    public static function getTempDir(): string
    {
        // @codeCoverageIgnoreStart
        if (function_exists('sys_get_temp_dir')) {
            $tmp = sys_get_temp_dir();
        } elseif (!empty($_SERVER['TMP'])) {
            $tmp = $_SERVER['TMP'];
        } elseif (!empty($_SERVER['TEMP'])) {
            $tmp = $_SERVER['TEMP'];
        } elseif (!empty($_SERVER['TMPDIR'])) {
            $tmp = $_SERVER['TMPDIR'];
        } else {
            $tmp = getcwd();
        }
        // @codeCoverageIgnoreEnd

        return $tmp;
    }

    /**
     * get bash is available
     *
     * @return bool
     */
    public static function shIsAvailable(): bool
    {
        // $checkCmd = "/usr/bin/env bash -c 'echo OK'";
        // $shell = 'echo $0';
        $checkCmd = "sh -c 'echo OK'";

        return self::execute($checkCmd, false) === 'OK';
    }

    /**
     * get bash is available
     *
     * @return bool
     */
    public static function bashIsAvailable(): bool
    {
        // $checkCmd = "/usr/bin/env bash -c 'echo OK'";
        // $shell = 'echo $0';
        $checkCmd = "bash -c 'echo OK'";

        return self::execute($checkCmd, false) === 'OK';
    }

    /**
     * get screen size of the terminal
     *
     * ```php
     * list($width, $height) = Sys::getScreenSize();
     * ```
     *
     * @from Yii2
     *
     * @param boolean $refresh whether to force checking and not re-use cached size value.
     *                         This is useful to detect changing window size while the application is running but may
     *                         not get up to date values on every terminal.
     *
     * @return array|boolean An array of ($width, $height) or false when it was not able to determine size.
     */
    public static function getScreenSize(bool $refresh = false)
    {
        static $size;
        if ($size !== null && !$refresh) {
            return $size;
        }

        if (self::shIsAvailable()) {
            // try stty if available
            $stty = [];
            if (exec('stty -a 2>&1', $stty)) {
                $sttyText = implode(' ', $stty);
                // linux: speed 38400 baud; rows 97; columns 362; line = 0;
                $pattern = '/rows\s+(\d+);\s*columns\s+(\d+);/mi';

                // mac: speed 9600 baud; 97 rows; 362 columns;
                if (self::isMac()) {
                    $pattern = '/(\d+)\s+rows;\s*(\d+)\s+columns;/mi';
                }

                if (preg_match($pattern, $sttyText, $matches)) {
                    return ($size = [$matches[2], $matches[1]]);
                }
            }

            // fallback to tput, which may not be updated on terminal resize
            if (($width = (int)exec('tput cols 2>&1')) > 0 && ($height = (int)exec('tput lines 2>&1')) > 0) {
                return ($size = [$width, $height]);
            }

            // fallback to ENV variables, which may not be updated on terminal resize
            if (($width = (int)getenv('COLUMNS')) > 0 && ($height = (int)getenv('LINES')) > 0) {
                return ($size = [$width, $height]);
            }
        }

        if (self::isWindows()) {
            $output = [];
            exec('mode con', $output);

            if (isset($output[1]) && strpos($output[1], 'CON') !== false) {
                return ($size = [
                    (int)preg_replace('~\D~', '', $output[3]),
                    (int)preg_replace('~\D~', '', $output[4])
                ]);
            }
        }

        return ($size = false);
    }
}
?>
--
11、XML 函数
XML 函数用于编解码 XML 数据、与数组互转、解析等操作，需引入 Swoft\Stdlib\Helper\XmlHelper。详情参阅 XmlHelper.php ( https://github.com/swoft-cloud/swoft-stdlib/blob/master/src/Helper/XmlHelper.php )文件。
decode(string $xml): array
    {
        return self::xmlToArray($xml);
    }

    /**
     * @param array $data
     *
     * @return string
     */
    public static function encode(array $data): string
    {
        $xml = '<xml>';
        $xml .= self::arrayToXml($data);
        $xml .= '</xml>';
        return $xml;
    }

    /**
     * @param string $xml
     *
     * @return array
     */
    public static function xmlToArray(string $xml): array
    {
        $string  = simplexml_load_string($xml, 'SimpleXMLElement', LIBXML_NOCDATA | LIBXML_NOBLANKS);
        $jsonStr = JsonHelper::encode($string);
        $data    = JsonHelper::decode($jsonStr, true);
        if ($data === false) {
            return [];
        }

        return $data;
    }

    /**
     * @param $data
     *
     * @return array
     */
    protected static function parseToArray($data): array
    {
        $res = null;
        if (is_object($data)) {
            $data = (array)$data;
        }
        if (is_array($data)) {
            foreach ($data as $key => $val) {
                if (is_iterable($val)) {
                    $res[$key] = self::parseToArray($val);
                } else {
                    $res[$key] = $val;
                }
            }
        }
        return $res;
    }

    /**
     * @param array $data
     *
     * @return string
     */
    public static function arrayToXml(array $data): string
    {
        $xml = '';
        if (!empty($data)) {
            foreach ($data as $key => $val) {
                $xml .= "<$key>";
                if (is_iterable($val)) {
                    $xml .= self::arrayToXml($val);
                } elseif (is_numeric($val)) {
                    $xml .= $val;
                } else {
                    $xml .= self::characterDataReplace($val);
                }
                $xml .= "</$key>";
            }
        }
        return $xml;
    }

    /**
     * @param string $string
     *
     * @return string
     */
    protected static function characterDataReplace(string $string): string
    {
        return sprintf('<![CDATA[%s]]>', $string);
    }
}
?>
--
12、通用函数
(1)、alias
获取路径别名。
function alias(string $key): string
(2)、bean
从容器中获取 bean 对象，等同于 Swoft::getBean(); 。
function bean(string $key): object
(3)、config
获取应用配置值。
function config(string $key, $default = null): mixed
(4)、container
获取容器对象。
function container(): Container
(5)、context
获取上下文对象。
function context(): ContextInterface
(6)、env
获取环境变量值。
function env(string $key = null, $default = null): mixed
(7)、event
获取事件管理器。
function event(): EventManager
(8)、fnmatch
文件名正则匹配。
function fnmatch(string $pattern, string $string): bool
(9)、printr
打印数据，类似 print_r，允许多参数。
function printr(...$vars): void
(10)、server
获取服务实例，包括 HTTP Server 和 WebSocket Server。
function server(): Server
(11)、sgo
开启新协程。
function sgo(callable $callable, bool $wait = true): void
(12)、srun
启动协程并等待执行结束。
function srun(callable $callable): bool
(14)、tap
向指定值调用闭包函数，然后返回该值。
function tap($value, Closure $callback = null): mixed
(15)、validate
数据验证。
function validate(array $data, string $validatorName, array $fields = [], array $userValidators = []): array
(16)、value
获取回调结果。
function value($value): mixed
(17)、vdump
转储数据，与 var_dump 类似。不同处在于 vdump 会增加一行打印位置提示。
--
--
七、错误处理
https://swoft.org/documents/v2/basic-components/error-dispose/
--













第六卷
()、
https://www.teamviewer.cn/cn/
# chuyuan
1142733640@qq.com
ctc135792468
--
--
--