^2_3^2workroom3工作室
--
//// 开发文档 (Swoft-v2.x-教程手册)
https://www.swoft.org/documents/index.html
//// 日期时间
2019-12-29
--
--
第一卷 框架概述 SWOFT
https://www.swoft.org/documents/v2/
--
1、SWOFT简述
Swoft 是一款基于 Swoole 扩展实现的 PHP 微服务协程框架。Swoft 能像 Go 一样，内置协程网络服务器及常用的协程客户端且常驻内存，不依赖传统的 PHP-FPM。有类似 Go 语言的协程操作方式，有类似 Spring Cloud 框架灵活的注解、强大的全局依赖注入容器、完善的服务治理、灵活强大的 AOP、标准的 PSR 规范实现等等。
--
2、SWOFT特性
Swoft 通过长达三年的积累和方向的探索，把 Swoft 打造成 PHP 界的 Spring Cloud, 它是 PHP 高性能框架和微服务治理的最佳选择。
内置高性能网络服务器（Http/Websocket/RPC/TCP）；
灵活的组件功能；
强大的注解功能；
多样化的命令终端（控制台）；
强大的面向切面编程（AOP）；
容器管理，依赖注入（DI）；
灵活的事件机制；
基于PSR-7的HTTP消息的实现；
基于PSR-14的事件管理；
基于PSR-15的中间件；
国际化（i18n）支持；
简单有效的参数验证器；
高性能连接池（Mysql/Redis/RPC），自动重新连接；
数据库高度兼容Laravel的使用方式；
Redis高度兼容Laravel的使用方式；
秒级定时任务；
Session 管理；
进程池；
秒级定时任务；
Session 管理；
进程池；
服务注册与发现；
配置中心；
服务限流；
服务降级；
服务熔断；
Apollo；
Consul；
--
3、关于 Swoft
Swoft 是基于 Swoole 的企业级 PHP 应用程序开发框架，大量开发人员使用 Swoft Framework 来创建高性能、易于测试和可重用的代码。
Swoft 开源框架自 2018 年 3 月 6 日发布以来，我们秉承简单、高效、稳定的宗旨持续迭代升级。伴随着 1.x 的开发迭代和 Swoole 4 全协程化，1.x 的底层架构已经不再合适，所以在 2018 年 11 月开始规划 2.x。新版本底层借鉴 1.x 的经验全部重写，采用 Swoole Hook 全协程化，整体相比 1.x 更易上手，稳定性也更高。
Swoft 是一款轻量级的框架，所有组件均可以自定义且支持按需加载使用。
Swoft 框架可用于开发任何 Web 应用程序，构建高性能的 Web 系统、API、中间件、基础服务等。
--
4、优势
//// Swoft Framework 的优点
以组件化方式开发，开发者可以自定义组件并按需加载使用；
良好 Web MVC 设计，它为 Web 开发框架提供了一个很好的选择；
PHP 开发者可快速上手，数据库、缓存的使用均高度兼容 Laravel；
所有组件严格通过单元测试及压力测试；
--
5、社区
Swoft 官方 QQ 群 1：548173319（点击添加）
Swoft 官方 QQ 群 2：778656850（点击添加）
Swoft 社区：https://learnku.com/swoft
--
6、支持
您的支持是对开发组的最大鼓励，您可以通过以下方式来支持我们。
赞助 https://www.swoft.org/donation/
参与贡献 https://www.swoft.org/documents/v2/contribute/sub-questions/
--
--
第二卷 开发指南
--
--
一、版本更新
http://swoft.org/documents/v2/dev-guide/update/
--
1、v2.0.8[WIP]
(1)、修复(Fixed)
修复 ws server 的 message response.finish 兼容 swoole 4.4.12 问题 d724a949；
修复 console 组件中拥有短选项的选项获取值不同步问题 ac41eca；
修复 部分字符串操作不兼容 php 7.4 的问题 b4d0e90；
修复 输入未知命令时，显示http server 命令帮助信息有误 684807e；
修复 去除 process 组件中无效的调试语句 2bc84aa；
打包为phar后不能正确的加载同目录下的 .env 文件问题 8046c15；
(2)、更新(Update)
调整 路由没找到时抛出的异常将会携带错误 code 7e06afa；
(3)、增强(Enhancement)
优化 phar 包构建速度，现在打包时间将会大幅度缩短 1055fff；
优化 console 命令参数和选项的解析绑定，设置的类型的将会格式化为对应的类型 7dc0d58；
--
2、v2.0.7(2019-11-18)
升级提示：Swoole\WebSocket\Server::push 第四个参数 4.4.12 后改为了 int 类型。
(1)、修复(Fixed)
修复 config 注入时，没有找到值也会使用对应类型的默认值覆盖属性，导致属性默认值被覆盖 d84d50a7；
修复 ws server 中使用message调度时，没有过滤空数据，导致多发出一个响应。避免方法swoft-cloud/swoft#1002 d84d50a7；
修复 tcp server 中使用message调度时，没有过滤空数据，导致多发出一个响应。07a01ba1；
修复 独立使用console组件时缺少 swoft/stdlib 库依赖 c569c81a；
修复 ArrayHelper::get 传入key为 integer 时，报参数错误 a44dcad；
修复 console 渲染使用table，有int值时，计算宽度报类型错误 74a835ab；
修复 error 组件中用户无法自定义设置默认的错误处理级别 4c78aeb；
修复 启用和禁用 组件设置 isEnable() 不生效的问题 da8c51e56；
修复 在 cygwin 环境使用 uniqid() 方法必须将第二个参数设置为 true c7f688f；
修复 在 cygwin 环境不能够设置进程title而导致报错 c466f6a；
修复 使用 http response->delCookie() 无法删除浏览器的cookie数据问题 8eb9241；
修复 ws server消息调度时，接收到的ext数据不一定是数组导致报错 ff45b35；
修复 日志文件按时间拆分问题c195413；
修复 日志 JSON 格式小问题a3fc6b9；
修复 rpc 服务提供者 getList 调用两次问题fd03e71；
修复 redis cluster 不支持 auth 参数7a678f；
修复 模型查询 json 类型, 不支持 array 6023a9；
修复 redis multi 操作没有及时是否连接 e5f698；
修复 redis 不支持 expireAt, geoRadius 749241；
修复 crontab 时间戳检测偏差问题 eb08a46；
(2)、更新(Update)
更新 console 在渲染 help信息之前也会发出事件 ConsoleEvent::SHOW_HELP_BEFORE d3f7bc3；
简化和统一 http, ws, tcp, rpc server管理命令逻辑 f202c826；
更新 ws 和 tcp Connection类添加 newFromArray 和 toArray 方法，方便通过第三方存储(redis)时导出信息和恢复连接 a8b0b7c；
优化 server 添加统一的 swoole pipe message 事件处理，在 ws, tcp 中使用swoft事件来处理进程间消息 1c51a8c；
(3)、增强(Enhancement)
现在 tcp 请求支持添加全局或对应的方法中间件，流程和使用跟http中间件类似。仅当使用系统调度时有用 6b593877；
现在 websocket message 请求支持添加全局或对应的方法中间件，流程和使用跟http中间件类似。仅当使用系统调度时有用 9739815；
事件管理允许设置 destroyAfterFire 在每次事件调度后清理事件中携带的数据 50bf43d3；
数据库错误异常新增 code 返回fd306f4；
协程文件操作 writeFile 新增写失败异常08c4244；
RPC 新增参数验证8646fc5；
--
3、v2.0.6(2019-09-21)
(1)、升级提示
通过参数注入接收websocket原始数据时，现在需要加上类型 string。例如： public function echo(string $data)；
ws server 中使用message调度时，没有过滤空数据，导致多发出一个响应。避免方法swoft-cloud/swoft#1002；
(2)、修复(Fixed)
修复 ws server收到消息时，默认使用当前fd作为响应消息的客户端 3a8890cf；
修复 ws server通过swoole server拿到的全部连接里，fd的类型可能不是整型导致报错。0fa79d7；
修复 stdlib SystemHelper 在 windows 10 中会被 Defender 删除 71c2893；
修复 increment/decrement 多拿了一个连接 94c7171；
修复 模型属性 $modelTimestamps 关闭了无效 94c7171；
修复 在初始化前调用了log，导致可能会在启动阶段报context丢失错误 5a27704f；
修复 ws server的握手和open使用同一个顶级协程ID，如果有一个先执行完成，可能会导致后面的出现session丢失 c2cd17a；
修复 after 定时器传递参数 bug 8ed609a；
修复定时任务内存泄漏和日志打印数据丢失问题 aa6bc32；
优化 Http server sgo 处理流程 e60d92e；
修复数据库在事物情况下重连导致数据不一致问题 c2e87f2；
修复 Aop 极端情况返回 0 问题 85bc1b1；
修复 BeanFactory::createBean() 方法创建问题c2e2c89；
修复 RPC 错误数据是字符串问题 3a34658；
修复 redisCluster 初始化问题3a60c06；
修复 DbException 没有抛出 Database 的异常 Code3a60c06；
修复 ModelAttribute 的 getter 和 setter 驼峰判断错误2e2f0f1；
修复 Aggregate 聚合, 返回字符串强行转换 int错误7aa98a6；
修复模型 updateCounters 方法更新之后没有同步实体数据967d6f8；
(3)、更新(Update)
调整 ws server在worker 退出时自动关闭连接，添加开关配置，可以选择是否开启。3a8890c；
ws server 新增事件： MESSAGE_PUSH` OPEN_BEFORE MESSAGE_RECEIVE` e1b0583；
(4)、增强(Enhancement)
新增日志按时间切割 f649df2；
新增日志支持传递额外参数 55d5533；
调整和新增了一些ws server相关事件，方便用户使用 e1b0583；
模型对 Prop 支持 630aad8；
新增连接连接池(mysql/redis/rpc)启动初始化连接功能 a367173；
tcp server 使用长度分包时，支持自定义头部数据打包、解包格式 a6fbe932；
RPC 调用错误信息调整 d9226b1；
新增操作 Database 异常, 打印控制台 错误 SQL3a60c06；
新增操作数据迁移 int 系列 长度支持967d6f8；
新增获取原始 sql 方法getRawSql967d6f8；
扩展updateOrInsert和updateOrCreate 支持自增参数967d6f8；
(5)、扩展(Extra)
swoftcli 支持类生成，创建新的应用、组件结构。使用请查看文档；
swoftTracker 支持方便开发者调试；
--
4、v2.0.5-beta(2019-08-06)
(1)、升级提示
请使用 context() 代替 Context::mustGet()；
这个版本开始验证器默认关闭，需要开发者开启 validator setting；
(2)、修复(Fixed)
修复提前中断请求逻辑可能导致无法正确的格式化对应的Content-Type f031398；
修复使用sgo创建子协程，在结束时没有清理与顶级协程的映射关系 de11ae5b；
修复 Xml 格式解析方法 24d0038；
修复类代理 Unique 字符串问题 444ddeb；
修复 context()->get() 存在问题以及废弃 Context::mustGet() 方法 6acc1b5；
修复接口注入，类名访问错误 2d9a31f；
修复 模型使用 paginate 方法, 结果集没有映射字段3027287；
修复 websocket server 里，当有多个worker，主动关闭非当前worker连接时报错 7666969；
(3)、更新(Update)
默认的 worker num 设置通过 swoole_cpu_num 函数获取 553f6500；
验证器调整成，默认非必须，用户自己开启 e5b258d；
不再抛出swoft内部的 ContainerException 到用户使用层 1e74893；
console output 新增 confirm` select` 等交互方法 0181138a；
(4)、增强(Enhancement)
console 命令选项设置 CommandOption，现在允许选项描述为多行信息 e5914983；
websocket server 的全部消息发送方法，支持传入 opcode 参数 dc164ffe9；
websocket 模块允许设置当前模块的默认 opcode，用于自动处理返回数据设置 opcode 9e3e9672；
增强 websocket 相关类，现在消息处理方法允许注入更多数据对象类型 Request` Response` 3d6c60b4；
当worker退出时，websocket server 会自动关闭所有连接 5ea10ecc；
Add Timer 定时器封装 eb92ee6；
Add Coroutine 方法封装 d8c2b88；
(5)、扩展(Extra)
swoft/crontab 秒级别定时任务；
swoft/whoops 对 filp/whoops 在swoft中使用的简单封装，用于渲染并显示更加利于阅读的错误信息；
--
5、v2.0.4-beta(2019-07-21)
(1)、升级注意
请去掉 bin/swoft 里的 Runtime::enanbleCoroutine() 设置；
请确保 swoole 的 swoole.use_shortname 的值为 On；
从这个版本开始要求 swoole 4.4.1+；
(2)、增强(Enhancement)
Swoft\Http\Message\Request 新增 getHeaderLines() (74a2a91)；
Aop 新增 getArgsMap() 和 getClassName() 方法 (c47e785)；
新增 srun() 函数，用于协程调度 (3c4a6a4)；
优化 server 事件(onStart / onWorkStart / onWorkStop / onShutdown)，事件自带支持协程 (a8d5a8d)；
新增投递同步阻塞任务(ec938e5)；
新增 Redis call 方法, 用于使用同一连接操作(92456987)；
兼容 Swoole 4.4.x；
(3)、修复(Fixed)
修复 迁移类名太长导致记录类名不全(58314b8)；
修复 实体查询之后使用Setter更新字段值之后update更新无效(caadf0e)；
修复 stop 后删除pid文件的结果返回错误，导致restart失败 (2be450bf11)；
修复 i18n 设置默认语言不生效的问题 (b401a504e)；
修复 ws server在有多个worker时，无法主动关闭其他worker的连接(271b6398)；
修复 http server接收xml请求时，content type 不能正确匹配(2ff9a4e61)；
修复 使用 Database, json 操作无效(92456987)；
修复 limiter 限速器 Redis 加前缀无法使用问题(7b54d4c)；
(4)、更新(Update)
更新 ws server 可以通过配置 disabledModules 来禁用 ws 模块(fa31111d)；
(5)、扩展(Extra)
在官网增加案例展示，欢迎大家提交案例到官方案例仓库 swoft-cloud/swoft-case；
在GitHub上对文档的修改，将会自动更新到官网文档，不再需要手动刷新；
(6)、新增(New)
进程管理(c61b8f7)；
自定义用户进程(c328d54)；
进程池(d2e6290)；
TCP server 基本可用；
--
6、v2.0.3-beta(2019-07-08)
(1)、不兼容(Incompatible)
移除 request->json() 方法(c9e8f04) 替代方法 getParserdBody()；
应用日志和控制台日志 levels 由数组配置改成，字符串配置，详细见文档；
(2)、新增(Enhancement)
新增接口依赖注入(6169f84)；
新增 getFile 方法获取文件上传保存之后的信息(fe7e3a6)；
新增 restart() 服务新增重启方法(2ffec37)；
新增调用 1.x RPC 服务支持(30d73c3)；
新增 AOP 类名匹配支持正则表达式(bc5e479)；
新增 RPC Server /Http Server 中间件命名空间 use 错误提示(b1cec04)；
新增 验证器排除属性字段 unfields(b1bf44f)；
新增 自动写入时间戳(dc58011)；
新增 模型动作事件(dc58011)；
新增 数据库迁移(26bb464)；
新增 实体自动与 json 和数组互转(dc58011)；
新增 模型批量更新方法batchUpdateByIds(dc58011)；
(3)、修复(Fixed)
修复 cookies 设置时的一些问题，增加一些 withCookie 相关方法(b05afbb01)；
修复 在console使用协程方式运行命令时，没有捕获处理错误(8a5418bf)；
修复 websocket server 重启命令没有先停止旧server问题(db2d935)；
修复任务返回值为 null 问题(a69347c)；
修复 RPC Server 只有类中间件无法使用问题()204bc7f；
修复 RPC Server 返回值为 null 问题(4d091be)；
修复 Logger 和 CLog 日志等级无法覆盖和无效问题(8eb8aba)；
修复 模型里面的属性不支持自定义表达式(dc58011)；
(4)、更新(Update)
验证器优化，支持自定义验证规则(d959a4f)；
重命名错误处理管理类 ErrorHanlders 为 ErrorManager (f3a8f04b)；
console组件的异常处理改为由error组件提供的统一处理风格 (4f47204)；
console组件允许设置禁用命令组(c5a0269)；
在默认的错误处理中，允许设置错误捕获级别。默认级别是 E_ALL | E_STRICT (afff9029)；
优化 启动ws server时同时启用了http处理功能，信息面板添加提示(83a81170)；
优化 启动ws server 并同时添加rpc server启动，信息面板没有显示 rpc server信息(3d1d0d848)；
(5)、扩展(Extra)
文档添加支持通过google进行搜索；
新增 apollo 组件；
新增 consul 组件；
新增 breaker 组件；
新增 limter 组件；
新增 tcp-server 组件；
--
7、v2.0.2-beta(2019-06-21)
(1)、新增(Enhancement)
新增 $request->parsedQuery() 方法 (ab45089)；
新增 Bean 属性注入基础数据类型(string/int/bool/float/array)，自动根据注释类型转换。(e3d4085)；
新增 db(), 使 Model/Query/DB 支持切库(f3b12c9)；
新增 DbSelectorInterface 用于根据业务自动切库(b36ca03)；
新增 Http server 增加Cookies响应支持 (1a024bf)；
新增 devtool 组件的实体生成(14b4d39c)；
新增 允许注册 swoole 的 pipeMessage, packet 事件[afec0e3f]；
新增 添加更多启动时的相关事件[8aaa38c4]；
新增 validate() 不依赖注解验证方式(cc35560)；
新增 RPC 调用返回错误 RpcResponseException 异常(baa482f)；
新增 允许注册 swoole 的 pipeMessage, packet 事件(afec0e3f)；
新增 添加更多启动时的相关事件(8aaa38c4)；
(2)、修复(Fixed)
修复 paginate 无法指定查询字段(308d330)；
修复 实体 join 操作，显示不出关联表数据 (446a3a2)；
修复 实体属性名attributes等与系统定义属性冲突问题 (1a9d25b)；
修复 AOP 切面重复执行问题 (54e00ac)；
修复 Http 服务全局异常 contentType 失效问题(e704116)；
修复 Http server在启用https 时，type 检查无法通过 (3e9b431)；
修复 Http server通过data响应html时可能出现错误(e5513df)；
修复 控制器 table 数据显示 (4d27718)；
修复 devtool 生成的 phpstorm meta文件key重复(1838552)；
修复 ws-server 参数路由匹配失败(4d3392e6)；
修复 Http 服务 content-type 多值解析错误问题(1657979)；
修复 Co::multi 抛出异常调用错误问题(d0ff0f7)；
修复 body 字符串无解析调用错误问题(32abf60)；
修复 通过 setter操作实体 toArray失效问题(9c0f9505)；
现在停止server(包含Ctrl+C)时总是会删除pid文件，修复没有删除pid文件导致docker重启失败问题(6a96b2c)；
修复 通过 @Inject 注入Redis连接池没有释放以及连接池全部空闲判断问题(feac3700)；
修复 数据库开启事物多连接池操作错误(3f80474)；
修复 init() 方法中使用 config() 函数问题(fe9b92b)；
修复 getParsedQuery() 方法初始化问题(8e05836)；
修复 一些bean会出现重复初始化(例如 config)问题 (f8ef5a9a)；
修复 Autoloader 文件与其它composer包文件冲突问题 (ba19af363)；
(3)、更新(Update)
修改模型方法insert,insertGetId,updateOrInsert只会插入定义了@Column字段(9c0f9505)；
启动swoft时加入冲突扩展相关的运行环境检查(7fa7188f)；
调整 count,sum,avg,max,min 返回值类型(c9b5e17a)；
Http server 路由匹配顺序优化(d8fb588)；
完善 RPC Client 调用错误信息提示(a1e56eb)；
调整 Redis zAdd 成员和分数的位置⚠️不向下兼容(1a3275b3)；
调整 如果没有添加验证注解，会跳过验证解析相关流程(582c806cc)；
去除swoole中已经废弃的 buffer full/empty 事件相关代码 (873a97bed)；
优化 Http server 验证器流程(0e73a8c)；
(4)、扩展(Extra)
swoft/view 添加通过 @View 渲染视图支持；
--
8、v2.0.1-beta (2019-05-29)
(1)、新增(Enhancement)
新增验证器不存在错误提示(5ba8682)；
新增 AOP 代理类名称标识 _PROXY_(5ba8682)；
新增实体字段值类型转错误异常提示(ab3cfea)；
新增 BeanFactory::getBeans() 根据类名查询使用实例(999c10f)；
新增 Model getAttributeValue 获取字段值方法(642d791e)；
新增 Get 方式参数验证(6452a37)；
新增 Redis 通过 Inject 方式注入使用(fc0a88e)；
新增 RRC 服务全局异常处理(1653b24)；
(2)、修复(Fixed)
修复 CLog 日志调用栈错误(868102f)；
修复 Co::multi 调用失败错误数据格式(5ba8682)；
修复 Function.php 重复加载(b063dd1)；
修复 Logger 日志调用栈错误(ab3cfea)；
修复 worker 进程退出未释放(close)数据库、缓存、RPC 连接池(5b1baa5)；
修复 开发者自定义 content-type 失效问题(22cf706)；
修复 request/session 级别销毁失效问题(e0d1493)；
修复 bean 名称包含 . 点号失效问题(dc37c92)；
修复连接池 maxIdleTime 参数无效问题(0e05591)；
修复 文件上传 (10bc7fa)；
修复 默认输出编码为UTF8 (755c8cf)；
优化 Redis 配置类型转换(533b592)；
打包为phar运行时路径错误(533b592)；
(3)、Swoft-cli
修复一些问题 swoft-cli；
发布新版本时自动通过travis部署phar到GitHub release (d1503b2)；
(4)、Devtool
新 bean 方法代码智能提示(bean()`/BeanFactory::getBean()/Swoft::getBean()`)(b63fe07)；
--
9、v2.0.0-beta (2019-05-21)
Swoft 2 重构归来，基于 Swoole hook 方式，底层完全重构，相比之前更佳简单、稳定、易上手。
(1)、功能特性
内置高性能网络服务器(Http/Websocket)；
灵活的组件化；
灵活的注解功能；
多样化命令终端(Console)；
强大的切面编程（AOP）；
完善的容器管理、依赖注入 (DI)；
灵活的事件机制；
基于 PSR-7 的 HTTP 消息实现；
基于 PSR-14 的事件管理器；
基于 PSR-15 的中间件；
可扩展的高性能 RPC；
国际化(i18n)支持；
简单高效的参数验证器；
高性能连接池(Mysql/Redis/RPC)，自带断线重连；
数据库高度兼容 laravel；
缓存 Redis 高度兼容 Laravel；
高效任务处理；
灵活的异常处理；
强大的日志系统；
--
--
二、贡献规范
https://www.swoft.org/documents/v2/dev-guide/contribute-standard/
Swoft 开源框架，非商业项目，由开源组织开发与维护，这意味着任何人都可以为其开发和进步贡献力量。参与 Swoft 有多种方式：代码贡献、文档贡献、官网维护、社区维护。
--
1、代码贡献
Fork 组件代码库 swoft-component ( https://github.com/swoft-cloud/swoft-component )；
发送 Pull Request 修改请求；
等待 Swoft 开发组审核和合并；
所有官方维护的组件均由swoft-component ( https://github.com/swoft-cloud/swoft-component )项目统一合并后分发到各个组件。
--
2、参与 swoft 的开发是否很难
//// 通过对比 swoft 和传统框架, 来回答这个问题
(1)、框架定位
传统框架: 适合开发「巨石应用」, 所有功能都包含在同一份代码库中, 适合初创团队快速实现原型；
swoft: 致力于实现 PHP 下的微服务, 功能都由「组件」提供, 可以按照实际需求按需加载组装；
(2)、开发难度
///1/ 传统框架
熟悉经典的 lnmp 体系, 只用考虑 PHP 语法；
通常需要完整熟悉整个框架, 才可能参与开发, 老旧的框架提 PR 可能很久才会处理；
///2/ swoft
熟悉 swoole 以及网络编程的基础知识, 就能轻松用 PHP 写出并发能力远超 fpm；
开发组提供开发指南, 组件说明, 快速响应, 开发者可以选取一个简单的组件上手, 快速完成一个 PR；
难? 我亦无他，唯手熟尔。
--
3、开发步骤
(1)、使用 docker
推荐使用 docker 解决开发环境的困扰, 开发组维护了 swoft/swoft ( https://www.swoft.org/docs/2.x/zh-CN/introduction/update.html ) 和 swoft/alphp ( https://github.com/swoft-cloud/alphp ) 两个镜像, 简单示例。
//
//// 使用 docker-compose 进行服务编排
version: '3.1'
services: # 定义服务
    swoft: # 服务的名称
        image: swoft/alphp:cli
        volumes:
            - ../:/data # 挂载本地的源码到容器的 /data 目录下
        ports:
            - "80:9501" # 映射本地 80 端口到容器 9501 端口
        links: # 其他基础服务也可以用 docker 解决, 用不到可以先去掉
            - redis
            - mysql
            - rabbitmq       
        tty: true # 开启后, 可以使用 exec 进入到容器中
//
//// 简单使用
docker-compose up -d swoft # 启动服务
docker-compose exec swoft # 进入容器中
(2)、swoft 项目说明
//// swoft 包含2个重要项目
swoft-cloud/swoft-component: ( https://github.com/swoft-cloud/swoft-component ) swoft 源码, 组件都在此项目的 src/ 目录下；
swoft-cloud/swoft: ( https://github.com/swoft-cloud/swoft ) swoft 脚手架, 加载了全部组件并提供了所有组件的使用 demo；
//
//// 换一个说法
参与 swoft，其实在做应用层的事，业务中要怎么写，参考 swoft 中的 demo 就行，通俗说 – 造飞机。
参与 swoft-component，其实是参与其中具体的某个/某几个组件，通俗说 – 造飞机引擎。
//
//// swoft 的架构设计, 体现在 swoft 的组件化实现中
框架组件 framework: 框架核心工作, 以及框架核心配套的组件；
swoft 功能组件: 按照功能进行划分, 依赖框架组件, 可以按需加载, 常见的有rpc 全家桶( rpc rpc-server rpc-client )；cli 引用( console )；
如果只是想 造飞机, 只用给 swoft 项目提 PR 即可; 如果想 造飞机引擎, 需要给 swoft-component 提 PR, 本地还需要一份类似 swoft 项目的脚手架, 用来验证
(3)、举个例子: 参与 RPC 组件开发
如果对 RPC 的基本概念不熟悉, 参考 RPC 组件相关文档。新建一个空文件夹, 比如 swoft-test, 充当 swoft 项目的角色, 作为脚手架, 加载需要的组件。
//
//// 需要的基础文件
➜  swoft-test tree -L 2
.
├── app
│   ├── Application.php
│   └── bean.php
├── bin
│   ├── bootstrap.php
│   └── test.php
├── composer.json
├── config
是的, 只需要这么多, 从 swoft 复制过来即可。
//
//// 使用 composer 加载 swoft 组件
{
  "require": {
    "swoft/rpc": "dev-master",
    "swoft/rpc-server": "dev-master",
    "swoft/rpc-client": "dev-master"
  },
  "autoload": {
    "psr-4": {
      "App\\": "app/"
    },
  },
  "minimum-stability": "dev",
  "repositories": {
    "hyperf": {
      "type": "path",
      "url": "../swoft-component/src/*"
    },
    "packagist": {
      "type": "composer",
      "url": "https://mirrors.aliyun.com/composer/"
    }
  }
}
}
这里涉及 composer 从本地加载依赖文件的用法, 不熟悉可以参考 官方文档 composer-repository ( https://getcomposer.org/doc/04-schema.md#repositories )。
//
//// 好了, 更新
composer u --no-dev
之后就可以执行 php bin/swoft 来进行相应测试了, 如果遇到报错, 根据报错添加缺少的组件即可。
//
//// 修改 RPC 相关文件
修改 swoft-component 下的组件, 建议多和开发组交流, 有开发范式和 CI 来保证组件的开发质量和稳定性。
--
4、需要了解的更多知识
docker 基础知识。
github 如何提 PR. 推荐一个好用的工具, github desktop, 有快捷键快速提 PR。
composer 文档, 组件开发和生产项目有所差异, composer 提供了一些有意思的功能, 方便开发组件。
推荐使用 mac + phpstorm + docker, 构建全套开发环境. 有相关问题, 欢迎和开发组交流。
--
--
三、优质教程
https://www.swoft.org/documents/v2/dev-guide/course/
本章收集 Swoft 优质教程，方便开发者快速学习上手。如果您有好的优质教程，可以联系我们 (Swoft@qq.com)。
--
1、1.x 系列
(1)、视频
//// Sunny系列
// [收费]_Swoft高性能协程框架
http://www.yzmedu.com/course/263
//
//// 老司机系列
// Swoft速学基础篇
http://www.jtthink.com/course/65#1325
// Swoft基础进阶篇
http://www.jtthink.com/course/73
--
2、2.x 系列
(1)、文章
//// Swoft2.x 学习社区
https://learnku.com/swoft
//
//// [收费]_Swoft2.x从入门到微服务
https://www.kancloud.cn/sphynx/swoft
//
//// Swoft2.x 小白系列教程
https://8code.net/index/index/blog/type/back
(2)、视频
//// Sunny 系列
// [收费]_Swoft2.x入门到微服务
https://study.163.com/course/introduction.htm?courseId=1006515006
//
//// [收费]_老司机系列
// Swoft2.x 基础篇
http://www.jtthink.com/course/65
//
// Swoft2.x HTTP API 篇
http://www.jtthink.com/course/87
//
// Swoft2.x 微服务基础篇
http://www.jtthink.com/course/93
//
// swoft2.x 实战第一季
http://www.jtthink.com/course/98
--
--
四、开发注意事项
https://www.swoft.org/documents/v2/dev-guide/dev-note/
--
1、注意事项
(1)、禁止使用$_GET、$_POST、$GLOBALS、$_SERVER、$_FILES、$_COOKIE、$_SESSION、$_REQUEST、$_ENV等超全局变量。
(2)、谨慎使用global、static关键字。
(3)、不要在代码非协程环境中执行sleep以及其他睡眠函数，这样会导致整个进程阻塞，exit/die 是危险的，会导致 worker 进程退出。
(4)、不要在业务代码中使用 swoole 不支持的 hook, 例如 MongoDB`,pgsql client`, 如果需要使用这些扩展需要单独开用户进程执行。
(5)、无法 hook 的 io 都会同步阻塞进程, 导致协程无法切换, 直接的影响就是服务器大规模超时。
(6)、不建议使用 curl 扩展 类似的GuzzleHttp, 推荐使用 swoft 封装的网络请求包。
(7)、Swoole 短名开启 ,在 php.ini 中配置swoole.use_shortname = 'on'。
--
2、常见问题
(1)、The HTTP server have been running!(PID: xx)
出现这种问题，是因为服务已经启动了。通常两种方式解决，第一种方式，stop 服务。第二种方式，kill pid。
(2)、Could not scan for classes inside xxx which does not appear to be a file nor a folder
出现这种问题是composer源的问题，一般会在创建项目`(composer create swoft/swoft swoft)的时候出现，解决办法很简单只需要切换源全局设置即可。如：composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/`。
(3)、代码格式
推荐参照 PSR2 ( https://www.php-fig.org/psr/psr-2/ ) 代码规范。
--
--
五、常见内存溢出
https://www.swoft.org/documents/v2/dev-guide/memory-overflow/
--
1、内存溢出
内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。
内存泄漏通常情况下只能由获得程序源代码的程序员才能分析出来, 也是一个比较难以排查的问题，所以需要在开发前知道一些规范。内存溢出一直向一个 属性/变量 写数据, 写入超过内存最大限额, php 会抛出致命错误可能导致进程退出。要避免内存溢出，首先要知道常驻内存开发，局部变量处理完毕之后会被GC，静态变量/静态属性的值GC不会标记回收，需要用户自己管理。不建议使用 静态变量/静态属性 来共享内存, 因为用户很难管理自己的内存空间。
不同的进程中PHP变量不是共享，即使是全局变量，在A进程内修改了它的值，在B进程内是无效的，如果需要在不同的Worker进程内共享数据，可以用Redis、MySQL等工具实现Worker进程内共享数据。
(1)、为什么Config Bean不支持动态写入？
下面是 Config Bean 部分源码，你可能好奇，写入为啥会抛异常呢？下面我们就来分析这个吧！
//
<?php declare(strict_types=1);

namespace Swoft\Config;

use InvalidArgumentException;
use Swoft\Bean\Annotation\Mapping\Bean;
use Swoft\Config\Contract\ParserInterface;
use Swoft\Config\Exception\ConfigException;
use Swoft\Config\Parser\PhpParser;
use Swoft\Config\Parser\YamlParser;
use Swoft\Stdlib\Collection;
use Swoft\Stdlib\Helper\ArrayHelper;

/**
 * Class Config
 *
 * @Bean("config")
 *
 * @since 2.0
 */
class Config
{
    /**
     * The items contained in the collection.
     *
     * @var array
     */
    protected $items = [];

    // ......

    /**
     * Get value
     *
     * @param mixed $key
     *
     * @return mixed
     */
    public function offsetGet($key)
    {
        return ArrayHelper::get($this->items, $key);
    }

    /**
     * @param mixed $key
     * @param mixed $value
     *
     * @throws ConfigException
     */
    public function offsetSet($key, $value): void
    {
        throw new ConfigException('Config is not supported offsetSet!');
    }

    /**
     * @param string $key
     *
     * @throws ConfigException
     */
    public function offsetUnset($key): void
    {
        throw new ConfigException('Config is not supported offsetUnset!');
    }

    /**
     * @param array|string $keys
     *
     * @return Collection
     * @throws ConfigException
     */
    public function forget($keys): Collection
    {
        throw new ConfigException('Config is not supported forget!');
    }

    // ......
}
?>
//
在 Config 中有一个 item 属性，虽然他不是静态的。但是我们需要明白 单例的 Bean 是全局的生命周期 在创建启动时已经创建创建好了。如果 Config 支持了写入，可能因为某段代码修改了配置导致脏读，请求写入的配置是不会被垃圾回收。
//
//// 所以我们需要明白 Swoft Bean 的生命周期。下面是一张简单的 生命周期 Bean。
php bin/swoft
singleton bean
------------------------------request
                                |
request bean                    |
                                |
------------------------------response
singleton bean
------------------------------
singleton bean 是全局存在的, 所以 singleton 类型的 bean 值是不允许动态修改的。需要借助属性来存储 结果值 请使用 request/prototype 类型的 bean，详情参考 Bean 章节。
(2)、非常驻内存框架常用代码
<?php declare(strict_types=1);

namespace App\Model\Logic;

use App\Model\Data\UserData;
use Swoft\Bean\Annotation\Mapping\Inject;

class UserLogic
{

    /**
     * @Inject()
     *
     * @var UserData
     */
    private $userData;

    /**
     * @var array 
     */
    private static $userCache = [];

    /**
     * @var string
     */
    public static $lastError = '';


    /**
     * Get user list
     *
     * @param array $userIds
     *
     * @return array
     */
    public function getUsers(array $userIds): array
    {
        $users = [];
        foreach ($userIds as $k => $userId) {
            if (isset(self::$userCache[$userId])) {
                $users[] = self::$userCache[$userId];

                unset($userIds[$k]);
            }
        }

        if ( empty( $userIds ) ) {
            return $users;
        }

        $list = $this->userData->getList($userIds);

        if (empty($list)) {
            self::$lastError = 'get user fail';

            return [];
        }

        foreach ($list as $user) {
            $userId = $user['uid'];

            self::$userCache[$userId] = $user;

            $users[] = self::$userCache[$userId];
        }

        return $users;
    }
}
?>
//
//// 上面代码有以下两个问题
使用 $userCache 静态属性来存储查询结果集，在同一进程下的请求数据是共享的，多个请求都写入当超过内存限额就会导致进程退出，也就是内存泄露。
使用 $lastError 静态属性来，存储上一次错误信息，在同一进程下的请求数据是共享的可能会导致数据错乱，这也就是swoft 没有类似 get_last_sql() 这样的函数。
//
说明：由于基于 php-fpm 的多进程模式开发,每个请求的数据是独立的, 使用静态变量共享本次请求数据也是常用的方法。但是在常驻内存下开发，请不要使用 静态属性/全局变量/静态变量 来共享数据，因为swoft 是基于 协程模式，一个进程下面的协程的数据都是共享。并发修改静态属性的情况就会导致数据错乱，使用 static，global 关键字定义变量也是同理，请谨慎使用。
--
--
第三卷、快速开始
--
一、框架安装
https://www.swoft.org/documents/v2/quick-start/install/
--
1、系统要求
Swoft 框架支持 Linux、macOS 以及 Windows 10 (通过 Windows 10 安装 WSL(Windows Subsystem for Linux，windows下的Linux子系统) 后可以使用大部分 Linux 功能，推荐安装 Ubuntu LTS 作为子系统)。
--
2、环境要求
(1)、必要部分
PHP，版本 >=7.1
PHP 包管理器 Composer
PCRE 库
PHP 扩展 Swoole，版本 >=4.3
额外扩展：PDO、Redis
(2)、冲突部分
下方列出部分已知与 Swoole 存在冲突的 PHP 扩展，请在使用 Swoft 时移除安装或禁用：Xdebug、Xhprof、Blackfire、Zend、trace、Uopz。
--
3、安装方式
(1)、通过 Docker 安装
docker run -p 18306:18306 --name swoft swoft/swoft
(2)、通过 Docker Compose 安装
git clone https://github.com/swoft-cloud/swoft
cd swoft
docker-compose up
(3)、通过 Composer 安装
composer create-project swoft/swoft Swoft
提示：建议全局配置 Composer 国内镜像以加速下载、更新包，参考：阿里云 Composer 全量镜像( https://developer.aliyun.com/composer )。
(4)、手动安装
git clone https://github.com/swoft-cloud/swoft
cd swoft
composer install
cp .env.example .env
# 编辑 .env 文件，根据需要调整相关环境配置
(5)、通过 Swoft CLI 创建
关于 Swoft CLI 工具，请查阅 Swoft CLI 文档( https://www.swoft.org/documents/v2/dev-tools/swoft-cli )，该工具支持从不同模板项目中快速创建一个干净的 Swoft 应用。
php swoftcli.phar create:app --type full Swoft-Full
php swoftcli.phar create:app --type ws Swoft-WebSocket
php swoftcli.phar create:app --type tcp Swoft-TCP
--
4、IDE 插件
通过文本编辑器进行 Swoft 开发时，Swoft 的注解功能虽然便捷，但仍需要 use 注解相对应的命名空间，这显然不是一个高效的做法。我们推荐在使用集成开发环境 IDEA 或 PhpStorm 时，通过插件市场搜索并安装 PHP Annotations 插件以提供注解命名空间自动补全、注解属性代码提醒、注解类跳转等非常有助于提升开发效率的功能。
--
--
二、目录结构
https://www.swoft.org/documents/v2/quick-start/directory-struct/
--
1、简介
//// 一个完整的 Swoft 应用包含
Console 应用；
HTTP 服务（类似传统框架）；
WebSocket 服务；
RPC 服务；
TCP 服务；
说明：app 下的类目录为了避免部分文件夹名称没有复数单词而导致命名不统一，所以所有文件夹名称 统一使用单数。
--
2、完整结构
├── app/    ----- 应用代码目录
│   ├── Annotation/        ----- 定义注解相关
│   ├── Aspect/            ----- AOP 切面
│   ├── Common/            ----- 一些具有独立功能的 class bean
│   ├── Console/           ----- 命令行代码目录
│   ├── Exception/         ----- 定义异常类目录
│   │   └── Handler/           ----- 定义异常处理类目录
│   ├── Http/              ----- HTTP 服务代码目录
│   │   ├── Controller/
│   │   └── Middleware/
│   ├── Helper/            ----- 助手函数
│   ├── Listener/          ----- 事件监听器目录
│   ├── Model/             ----- 模型、逻辑等代码目录(这些层并不限定，根据需要使用)
│   │   ├── Dao/
│   │   ├── Data/
│   │   ├── Logic/
│   │   └── Entity/
│   ├── Rpc/               ----- RPC 服务代码目录
│   │   └── Service/
│   │   └── Middleware/
│   ├── WebSocket/         ----- WebSocket 服务代码目录
│   │   ├── Chat/
│   │   ├── Middleware/
│   │   └── ChatModule.php
│   ├── Tcp/               ----- TCP 服务代码目录
│   │   └── Controller/        ----- TCP 服务处理控制器目录
│   ├── Application.php    ----- 应用类文件继承自swoft核心
│   ├── AutoLoader.php     ----- 项目扫描等信息(应用本身也算是一个组件)
│   └── bean.php
├── bin/
│   ├── bootstrap.php
│   └── swoft              ----- Swoft 入口文件
├── config/                ----- 应用配置目录
│   ├── base.php               ----- 基础配置
│   └── db.php                 ----- 数据库配置
├── public/                ----- 公共目录
├── resource/              ----- 应用资源目录
│   ├── language/              ----- 语言资源目录  
│   └── view/                  ----- 视图资源目录  
├── runtime/               ----- 临时文件目录（日志、上传文件、文件缓存等）
├── test/                  ----- 单元测试目录
│   └── bootstrap.php
├── composer.json
├── phar.build.inc
└── phpunit.xml.dist
--
--
三、运行服务
https://www.swoft.org/documents/v2/quick-start/run-server/
--
1、简述
Swoft 拥有便捷的命令行工具和相应的服务管理命令，参阅 Swoft Devtool( https://www.swoft.org/documents/v2/dev-tools/swoft-devtool ) 了解更多。
--
2、HTTP 服务
# 启动 HTTP 服务
$ php ./bin/swoft http:start
#
# 以守护进程模式启动
$ php ./bin/swoft http:start -d
#
# 重启 HTTP 服务
$ php ./bin/swoft http:restart
#
# 重新加载 HTTP 服务
$ php ./bin/swoft http:reload
#
# 停止 HTTP 服务
$ php ./bin/swoft http:stop
--
3、WebSocket 服务
# 启动 WS 服务
$ php ./bin/swoft ws:start
#
# 以守护进程模式启动
$ php ./bin/swoft ws:start -d
#
# 重启 WS 服务
$ php ./bin/swoft ws:restart
#
# 重新加载 WS 服务
$ php ./bin/swoft ws:reload
#
# 关闭 WS 服务
$ php ./bin/swoft ws:stop
--
4、RPC 服务
# 启动 RPC 服务
$ php ./bin/swoft rpc:start
#
# 以守护进程模式启动
$ php ./bin/swoft rpc:start -d
#
# 重启 RPC 服务
$ php ./bin/swoft rpc:restart
#
# 重新加载 RPC 服务
$ php ./bin/swoft rpc:reload
#
# 关闭 RPC 服务
$ php ./bin/swoft rpc:stop
--
5、启动信息
默认情况下，在任何服务启动时控制台会显示相应的启动信息。如果在 .env 文件中开启了调试 SWOFT_DEBUG=1 将会在控制台中显示更多详细的信息。
//
//// 如果需要关闭这些信息，只需要编辑 app/Application.php 文件
public function getCLoggerConfig(): array
{
    $config = parent::getCLoggerConfig();

    // False: 关闭控制台日志打印
    $config['enable'] = true;

    // 日志等级
    $config['levels'] = 'error,warning';

    return $config;
}
编辑后重启 Swoft 相关服务生效。
--
--
第四卷 开发工具
--
一、PhpStorm
https://www.swoft.org/documents/v2/dev-tools/phpstorm/
--
1、Annotations 插件
通过文本编辑器的环境进行 Swoft 开发，在使用 Swoft 便捷的注解时，仍需要 use 注解相对应的命名空间， 这显然不是一个高效的做法。我们推荐在 PHPStorm 环境下，并安装 Jetbrain 自带的 PHP Annotations 插件，可提供注解命名空间自动补全，注解属性代码提醒，注解类跳转等非常有助于提升开发效率的功能。
--
--
二、Swoft CLI
https://www.swoft.org/documents/v2/dev-tools/swoft-cli/
--
1、简介
GitHub: https://github.com/swoft-cloud/swoft-cli
Swoft CLI 是一个独立的命令行应用，提供了一些内置的功能方便开发者使用：生成 Swoft 应用类文件，例如 HTTP 控制器，WebSocket 模块类等；监视用户 Swoft 项目的文件更改并自动重新启动服务器；快速创建新应用或组件；将一个 Swoft 应用打包成 Phar 包。
欢迎提供意见、贡献代码，Swoft CLI 是基于 Swoft 2.0 框架构建的应用，运行时同样需要安装 Swoole。
--
2、运行预览
$ php swoftcli.phar -h
🛠️ Command line tool application for quick use swoft (Version:  0.1.3)
Usage:
  swoftcli.phar COMMAND [arg0 arg1 arg2 ...] [--opt -v -h ...]
Options:
      --debug      Setting the application runtime debug level(0 - 4)
      --no-color   Disable color/ANSI for message output
  -h, --help       Display this help message
  -V, --version    Show application version information
      --expand     Expand sub-commands for all command groups
Available Commands:
  client         Provide some commands for quick connect tcp, ws server
  gen            Generate some common application template classes(alias: generate)
  new            Provide some commads for quick create new application or component(alias: create)
  phar           There are some command for help package application
  self-update    Update the swoft-cli to latest version from github(alias: selfupdate, update-self, updateself)
  serve          Provide some commands for manage and watch swoft server project
  system         Provide some system information commands[WIP](alias: sys)
  tool           Some internal tool commands, like ab, update-self

More command information, please use: swoftcli.phar COMMAND -h
--
3、安装
安装 Swoft CLI 非常简单，我们已经提供打包好的 Phar 放在 GitHub 上，只需从 Swoft CLI Releases - GitHub ( https://github.com/swoft-cloud/swoft-cli/releases ) 下载打包好的 swoftcli.phar 文件即可。当然你也可以通过 wget 命令下载。
//
//// 通过 wget 命令下载
wget https://github.com/swoft-cloud/swoft-cli/releases/download/{VERSION}/swoftcli.phar
wget https://github.com/swoft-cloud/swoft-cli/releases/download/v0.1.5/swoftcli.phar
注意：你需要替换 {VERSION} 部分为最新版本。
//
//// 检查包是否可用，打印版本信息
php swoftcli.phar -V
//
//// 显示帮助信息
php swoftcli.phar -h
--
4、全局使用
mv swoftcli.phar /usr/local/bin/swoftcli && chmod a+x /usr/local/bin/swoftcli
# 完成后检查是否可用
swoftcli -V
--
5、手动构建
//// 如果你需要通过最新的 Swoft CLI 或修改后的代码构建 Phar 包
// 克隆项目
git clone https://github.com/swoft-cloud/swoft-cli
cd swoft-cli
composer install
// 构建
php -d phar.readonly=0 ./bin/swoftcli phar:pack -o=swoftcli.phar
--
--
三、Swoft Devtool
https://www.swoft.org/documents/v2/dev-tools/swoft-devtool/
--
1、介绍
GitHub: https://github.com/swoft-cloud/swoft-devtool
Swoft 提供了一套内置的命令工具以方便开发者使用。
--
2、安装
//// 默认情况下开发工具已包含在 Swoft 框架中，如需重新安装只需执行下方命令
composer require swoft/devtool
--
3、帮助命令
命令行中所有项均可以通过加上 -h 参数显示更多可选参数提示，例如 php ./bin/swoft http:start -h。
$ php ./bin/swoft -h
Console application description (Version: 2.0.0)
Usage:
  ./bin/swoft COMMAND [arg0 arg1 arg2 ...] [--opt -v -h ...]
Options:
      --debug      Setting the application runtime debug level(0 - 4)
      --no-color   Disable color/ANSI for message output
  -h, --help       Display this help message
  -V, --version    Show application version information
      --expand     Expand sub-commands for all command groups
Available Commands:
  agent      This is an agent for Apllo config center
  app        There are some help command for application[by devtool]
  dclient    Provide some simple tcp, ws client for develop or testing[by devtool]
  demo       Class DemoCommand
  dinfo      There are some commands for application dev[by devtool]
  entity     Generate entity class by database table names[by devtool]
  http       Provide some commands to manage the swoft HTTP server(alias: httpsrv)
  issue      There are some commands for application dev[by devtool]
  migrate    Manage swoft project database migration commands[by devtool](alias: mig)
  process    Provides some command for manage process pool
  rpc        Provide some commands to manage swoft RPC server
  tcp        Provide some commands to manage swoft TCP server(alias: tcpsrv)
  test       Class TestCommand
  ws         Provide some commands to manage swoft websocket server(alias: wsserver,websocket
More command information, please use: ./bin/swoft COMMAND -h
--
4、更多功能
后续会根据用户需要增加更多功能，欢迎用户提供意见、贡献代码。
--
--
第五卷 基础组件
--
--
一、注解
https://www.swoft.org/documents/v2/basic-components/annotation/
--
1、概念介绍
注解（Annotation）又称标注，Java 最早在 2004 年的 JDK 5 中引入的一种注释机制。目前 PHP 官方版本并未提供内置元注解和注解概念，但我们通过 ReflectionClass 反射类解析 PHP 代码注释从而实现了自己的一套注解机制。
--
2、如何使用
就像我们日常开发写注释一样，只需在类、方法或成员变量上方按规则添加注释即可。
//
//// 如定义一个控制器及其路由
use Swoft\Http\Message\Request;
use Swoft\Http\Server\Annotation\Mapping\Controller;
use Swoft\Http\Server\Annotation\Mapping\RequestMapping;
/**
 * Class Home
 *
 * @Controller(prefix="home")
 */
class Home
{
    /**
     * 该方法路由地址为 /home/index
     *
     * @RequestMapping(route="/index", method="post")
     *
     * @param Request $request
     */
    public function index(Request $request)
    {
        // TODO:
    }
}
//
注意需引入相关注解（Annotation）类，且必须以 /** 开始并以 */ 结束，否则会导致无法解析！
--
3、开发规范
//// Swoft 框架注解规范如下
类注解：所有类注释后面；
属性注解：属性描述之后，其它注释之前；
方法注解：方法描述之后，其它注释之前；
请 严格 按照规范使用注解，避免产生错误。如有更佳方式，欢迎提供建议。
--
4、开发工具
参阅：快速开始 - 框架安装 - IDE 插件 ( https://www.swoft.org/documents/v2/quick-start/install/#ide-%E6%8F%92%E4%BB%B6 ) 在 IDEA 或 PhpStorm 中安装 PHP Annotation 插件以提供开发帮助。
--
--
二、容器
https://www.swoft.org/documents/v2/basic-components/container/
--
1、简介
Swoft 基于 PSR-11 规范设计了自己容器，并基于 注解 增强了它的功能。容器是 Swoft 最重要的设计，称得上是 Swoft 的核心精髓，也是 Swoft 各模块的实现基础。本章节将会对容器的相关基础知识做一个介绍，以便大家更好的理解容器。
--
2、前置知识 - IoC
IoC 即控制反转（Inversion of Control），它不是一门技术而是一种设计思想。利用 IoC 将你设计好的对象交给容器控制，而非传统地在你的对象内直接控制、处理。简单来说就是如此，理论知识总是如此，我们继续下文。
--
3、前置知识 - DI
DI 为依赖注入（Dependency Injection）的缩写，DI 其实也不是一门技术，它是一种实现 IoC 的方式。同样的，我们先初步认识 IoC 和 DI 的概念，然后继续阅读下方图文深入理解。
--
4、概念知识
我们知道一台标准的电脑拥有 USB 接口，通过 USB 接口可以扩展电脑功能，如：键盘、鼠标、U 盘、蓝牙、无线网卡等等。只要是拥有标准 USB 接口的设备，连接到电脑上就能使用。现在我们有一台没有 USB 接口的电脑，我们也拥有键盘、鼠标和 U 盘（均为标准 USB 接口设备），当我们需要使用键鼠、U 盘的功能时，就必须 依赖 USB 接口来实现我们的目标。
( 图 https://www.swoft.org/img/computer.png )
电脑 --USB-A--> 键盘/鼠标/U盘
说明：这里的 USB 接口指传统 USB 接口，即 USB-A 接口。
--
5、理解 IoC 与 DI
让我们继续，我们通过一些伪代码来理解上述的 IoC 及 DI。
//
///1/ 定义电脑
class Computer
{
    /** @var 电脑型号 */
    private $model;
    
    /** @var 永不断电！ */
    private $powerOn = true;
    
    public function __construct($model)
    {
        $this->model = $model;
    }
    
    public function useKeyboard()
    {
        // 使用键盘（写代码 yes~）
    }
    
    public function useMouse()
    {
        // 使用鼠标
    }
    
    public function useUDisk()
    {
        // 使用 U 盘
    }
}
//
///2/ USB接口定义
前文提到，我们现在没有 USB，所以我们得依赖 USB 接口实现键鼠、U 盘的使用。
class USBAHub
{
    public function writeCode($computer_model)
    {
      // 果真写代码！
        echo "电脑 {$computer_model} 已开机，我正在疯狂写代码<br>";
    }
    
    public function paintWithMouse($computer_model)
    {
        // 鼠标画图
        echo "电脑 {$computer_model} 已开机，我正在构建灵感美学<br>";
    }
    
    public function storageWithUDisk($computer_model)
    {
        // U 盘存储
        echo "电脑 {$computer_model} 已开机，我用 U 盘存了...（不可描述）<br>";
    }
}
//
///3/ USB接口实现
自从有了这个强大的 USB-A Hub 后，我们就能愉快的使用了。
class Computer
{
    private $model;
    
    private $powerOn = true;
    
    public function __construct($model)
    {
        $this->model = $model;
    }
    
    public function useKeyboard()
    {
        // 使用键盘写代码
        (new USBAHub)->writeCode($this->$model);
    }
    
    public function useMouse()
    {
        // 使用鼠标画图
        (new USBAHub)->paintWithMouse($this->$model);
    }
    
    public function useUDisk()
    {
        // 使用 U 盘存储
        (new USBAHub)->storageWithUDisk($this->$model);
    }
}
//
///4/ 当我们使用这台携带 USB 接口的电脑一天后
$computer = new Computer('神机 i999 + GXX9080Tx');
$computer->useKeyboard();
$computer->useMouse();
$computer->useUDisk();
//
/// 输出内容
电脑 神机 i999 + GXX9080Tx 已开机，我正在疯狂写代码
电脑 神机 i999 + GXX9080Tx 已开机，我正在构建灵感美学~
电脑 神机 i999 + GXX9080Tx 已开机，我用 U 盘存了...（不可描述）
//
可是即便是当年强大的神机也会面临岁月的折磨，我们的 USB 接口在某天变得老化，速度颇慢，跟不上时代的步伐，更不兼容最新的 Type-C 接口，于是我们准备更换到新一代的 USB-C（Type-C）。
( 图 https://www.swoft.org/img/upgrade.png )
电脑 --(旧)USB-A--> 键盘/鼠标/U盘
电脑 --(新)USB-C--> 键盘/鼠标/U盘
但是，USB 接口的更换等同于更换主板（忽略处理器、内存等接口版本差异），拆机、装机、插跳线、配置 BIOS 等工作极其麻烦，我们是否可以将这个工作交给 别人 来完成，从而我们当一个电脑的使用者就好？将这个复杂的工作、控制权交给所谓的“别人”替我们完成的思想就叫做 控制反转。
这个“别人”可以是电脑商贩，也可以是维修店或者朋友，我们现在将“别人”称之为“帮手”。我们将这项工作移交给 帮手 来完成，交给帮手完成的操作实现就是 依赖注入。有了帮手之后，我们通过 构造函数 将帮手 注入 到电脑中，就能轻松使用 USB 设备了。
//
///5/ 控制反转，依赖注入
use Components\Helper;
class Computer
{
    private $model;
    
    private $powerOn = true;
    
    private $helper;
    
    public function __construct($model, Helper $helper)
    {
        $this->model = $model;
        $this->helper = $helper;
    }
    
    public function useKeyboard()
    {
        // 使用键盘写代码
        $this->helper->writeCode($this->$model);
    }
    
    public function useMouse()
    {
        // 使用鼠标画图
        $this->helper->paintWithMouse($this->$model);
    }
    
    public function useUDisk()
    {
        // 使用 U 盘存储
        $this->helper->storageWithUDisk($this->$model);
    }
}
注入的方式有三种，分别是：基于构造函数、基于 setter 方法、基于接口。其中基于构造函数是最常见的注入方式。
//
///6/ 多版本使用
现在我们手中除了旧的 USB-A 的键鼠、U 盘外，也新购置了 USB-C 的键鼠、U 盘，所以我们在使用这台电脑时并不关心 USB 版本。
// 实例化 USB-A
$usbHub = new USBAHub();
// 如果 USB-A 老化，更新使用 USB-C
if($usbHub->isOld()) {
    $usbHub = new USBCHub();
}
// 使用 USB
$computer = new Computer('超级神机 i999 + XXX9080Ti', $usbHub);
为什么不用 USB-B 呢？USB -B 目前我们见得最多的是在打印机上，而 USB-B 和 USB-A 同样是单面插口，而 USB-C（Type-C）是双面插口（不区分正反面）。所以 USB-C 是更为合理的升级方案。
--
6、接口约束
前文我们通过电脑 USB 的例子理解了 IoC 和 DI，但缺少实际开发中最重要的一环——利用接口进行约束。我们应当通过接口类约束 USB-A 以及 USB-C 需要实现的功能，前文中的 帮手 即为接口。
//
///1/ 接口定义
interface HelperInterface()
{
    public function writeCode(string $model);
    
    public function paintWithMouse(string $model);
    
    public function storageWithUDisk(string $model);
    
    public function isOld(): bool;
}
//
///2/ 接口实现
而无论 USB-A 还是 USB-C 均需要实现该接口，以下用 USB-C 举例。
use Components\Interfaces\HelperInterface;
class USBCHub implements HelperInterface
{
    public function writeCode($computer_model)
    {
      // 键盘写代码
        echo "电脑 {$computer_model} 已开机，我正在疯狂写代码<br>";
    }
    
    public function paintWithMouse($computer_model)
    {
        // 鼠标画图
        echo "电脑 {$computer_model} 已开机，我正在构建灵感美学<br>";
    }
    
    public function storageWithUDisk($computer_model)
    {
        // U 盘存储
        echo "电脑 {$computer_model} 已开机，我用 U 盘存了...（不可描述）<br>";
    }
    
    /**
     * 是否老化
     */
    public function isOld()
    {
        return false;
    }
}
USB-C 也将在某天老化，那时可能会有 USB-D、USB-E、USB-F 存在，届时我们仅需根据 HelperInterface 实现相应的 USB-D、USB-E、USB-F 类，并将 USB-C 中 isOld 方法返回 true 即可实现更新，从而平滑过渡到新版本 USB 接口。
--
7、IoC 容器
我们通过前文充分了解了如何利用 DI 实现 IoC，而实际项目中我们可能会面临几十上百个类去处理依赖关系，且类之间还会存在嵌套等问题，那么我们手动实现 IoC 就变得非常困难，效率也低。IoC 容器的出现极其便捷的替我们解决了这一烦恼。
(1)、IoC 容器的主要功能
自动管理依赖关系，避免手工管理存在缺陷。
需要使用依赖时自动注入所需依赖。
管理对象生命周期。
为了更好理解 IoC 容器，我们通过一个简单的示例演示：（代码仅作演示用，Swoft 已提供完善强大且易用的 IoC 容器）。
--
--
三、AOP
https://www.swoft.org/documents/v2/basic-components/aop/
--
1、概念介绍
AOP（Aspect-oriented programming）即 面向切面的程序设计，AOP 和 OOP（Object-oriented programming）面向对象程序设计一样都是一种程序设计思想，AOP 只是 OOP 的补充和延伸，可以更方便的对业务代码进行解耦，从而提高代码质量和增加代码的可重用性。后面的篇章会结合实际案例，教会大家理解并学会使用 AOP。AOP 并不规定必须使用某种方式来实现。
--
2、场景
我们就日志记录功能入手带领大家理解 AOP 切面编程的优势。首先假设我们有以下需求：需要对某个接口做调用记录，记录接口的调用详情（调用参数，返回结果等）；当调用接口出现异常时，做特殊处理，比如记录异常日志、邮件通知运维小伙伴。
如上，我们定义了一个简单的需求，接下来我们去实现它，我们先不要考虑 AOP ，就先用你所熟悉的 OOP 思想来完成以上的需求。
(1)、传统 OOP 实现
///1/ 订单服务类
<?php declare(strict_types=1);
/**
 * 订单服务
 */
class OrderService
{
    /**
     * 生成订单
     *
     * @param string $product_name 商品名字
     * @param int    $quantity     购买数量
     * @param int    $user_id      用户 ID
     *
     * @return array
     */
    public function generateOrder($product_name, $quantity, $user_id): array
    {
        $price = 1000;
        $amount = $price * $quantity;
        $order = [
            'order_no'     => uniqid($user_id . time() . $amount), // 订单号
            'product_name' => $product_name,                       // 商品名称
            'price'        => $price,                              // 商品单价
            'quantity'     => $quantity,                           // 商品数量
            'amount'       => $amount                              // 订单总额
        ];
        return $order;
    }
}
?>
//
///2/ 添加调用日志
在传统的 OOP 思想下，我们要实现所需的功能，可以创建一个类继承 OrderService，然后重写 generateOrder 方法，最后在所有使用 OrderService 的地方替换成新建的类。示例。
<?php declare(strict_types=1);

/**
 * Class InheritOrderService
 *
 */
class InheritOrderService extends OrderService
{
    /**
     * @param string $product_name
     * @param int    $quantity
     * @param int    $user_id
     *
     * @return array
     * @throws Exception
     */
    public function generateOrder($product_name, $quantity, $user_id): array
    {
        // TODO: 记录接口调用参数
        try {
            $result = parent::generateOrder($product_name, $quantity, $user_id);
            // TODO: 处理父方法返回结果，根据返回结果进行相关处理
            return $result;
        } catch (Exception $e) {
            // TODO: 如有异常，记录异常日志并发送邮件，然后继续将异常抛出
            throw $e;
        }
    }
}
?>
//
///3/ 修改调用
最后在我们调用 OrderService 的地方，将 OrderService 替换为 InheritOrderService。
<?php declare(strict_types=1);
  // $order = new OrderService(); // 注释掉旧业务调用
  $order = new InheritOrderService();// 替换
  $order->generateOrder('MacBook Pro', 1, 10000);
?>
//
至此，经过上方的调整后，满足了我们的业务需求。现在我们回顾一下，过程似乎非常繁琐，耦合严重，甚至污染了 generateOrder 方法。如果项目中存在 100 处 OrderService 类的调用，我们就得找到这 100 个地方进行修改、替换，这就是 OOP 的思想。
这时你或许会想到使用中间件、拦截器等类似的方法来解决，其实这些方法本质上也是基于 AOP 的设计思想而来的。前文已经提到，AOP 是基于 OOP 的补充和延伸。
(2)、AOP 实现
AOP 的主要作用是在不侵入原有代码的情况下添加新的功能。我们知道 OOP 实际上就是对我们的功能属性、方法做一个抽象封装，能够清晰的划分逻辑单元。但是 OOP 只能够进行纵向的抽象封装，无法很好的解决 横向 的重复代码，而 AOP 则很好的解决了这一问题。
( 请看图示 https://www.swoft.org/img/OOP.png )
订单类 --> 检查权限 --> 记录日志 --> 相关订单操作 --> 结束
用户类 --> 检查权限 --> 记录日志 --> 相关用户操作 --> 结束
如上图所示，我们有两个类：订单类 和 用户类，我们对其相关功能做了封装。但是，权限检查、日志记录等功能就是在重复的编码，而利用 AOP 思想就可以将这些功能 横向切 出去，然后在适当的时候再将这些功能织入进来。
( 请看图示 https://www.swoft.org/img/AOP.png )
订单类 --(切出/织入)检查权限--> 相关订单操作 --(切出/织入)记录日志--> 结束
用户类 --(切出/织入)检查权限--> 相关用户操作 --(切出/织入)记录日志--> 结束
这就是 AOP。
--
3、相关术语
(1)、Advice（通知）
通知是织入到目标类连接点上的一段代码，例如上方的权限检查及记录日志。
(2)、Aspect（切面）
切面由通知和切点组成，通知明确了目的，而切点明确目的地。
(3)、Introduction（引介）
引介指向一个现有类增加方法或字段属性。引介还可以在不改变现有类代码的情况下实现新的接口。
(4)、Joinpoint（连接点）
程序执行的某个特定位置，将通知放置的地方。如方法调用前、方法调用后、返回、抛出异常等。允许使用通知的地方都可称为连接点。
(5)、Pointcut（切点）
切点指需织入目标的方法。假设一个目标对象（类）中拥有 10 个方法，需要在其中 3 个方法中织入通知，这 3 个方法称为切点。
(6)、Proxy（代理）
应用通知的对象，详细内容参见设计模式里面的代理模式。代理实现了切面的业务， Swoft 使用了 PHP-Parser 库实现 AOP。
(7)、Target（目标对象）
被通知的对象类。目标含有真正的业务逻辑，可被无感知的织入。
(8)、Weaving（织入）
将切面应用至目标对象以创建新代理对象的过程。
--
4、运用声明
(1)、声明切面
//// 通过注解 @Aspect 将类定义为切面类
<?php declare(strict_types=1);
use Swoft\Aop\Annotation\Mapping\Aspect;
/**
 * @Aspect(order=1)
 */
class DemoAspect
{
    // TODO: ...
}
?>
order：用于指定优先级，数字越小则优先执行。
(2)、声明切点
目标类必须指定为携带 namespace 的完整路径或如示例代码中在顶部 use。
//
//// 示例代码
<?php declare(strict_types=1);

namespace App\Aspect;

use App\Services\OrderService;
use App\Services\UserService;
use Swoft\Aop\Annotation\Mapping\Aspect;
use Swoft\Aop\Annotation\Mapping\PointAnnotation;
use Swoft\Aop\Annotation\Mapping\PointBean;
use Swoft\Aop\Annotation\Mapping\PointExecution;
use Swoft\Http\Server\Annotation\Mapping\RequestMapping;

/**
 * @Aspect(order=1)
 *
 * @PointBean(
 *     include={OrderService::class,UserService::class},
 *     exclude={}
 * )
 *
 * @PointAnnotation(
 *     include={RequestMapping::class},
 *     exclude={}
 * )
 *
 * @PointExecution(
 *     include={OrderService::createOrder,UserService::getUserBalance},
 *     exclude={OrderService::generateOrder}
 * )
 */
class DemoAspect
{
    // TODO: ...
}
?>
//
//// PointBean：定义目标类切点
include：需被 指定 为切点的目标类集合；
exclude：需被 排除 为切点的目标类集合；
//
//// PointAnnotation：定义 注解类 切点，所有使用对应注解的方法均会通过该切面类代理
inlucde：需被 织入 的注解类集合；
exclude：需被 排除 的注解类集合；
//
//// PointExecution：定义确切的目标类方法。
include：需被 织入 的目标类方法集合，支持正则表达式；
exclude：需被 排除 的目标类方法集合，支持正则表达式；
使用正则表达式时，参数内容 必须 使用双引号 " " 包裹；命名空间分隔符 必须 使用 \ 转义，同时双引号内 必须 是类的完整路径。以上注解定义的关系为并集，定义的排除为并集后的结果。建议为了便于理解和使用，一个切面类尽量只使用其中一个注解。
(3)、声明通知
<?php declare(strict_types=1);

namespace App\Aspect;

use App\Services\OrderService;
use App\Services\UserService;
use Swoft\Aop\Annotation\Mapping\After;
use Swoft\Aop\Annotation\Mapping\AfterReturning;
use Swoft\Aop\Annotation\Mapping\AfterThrowing;
use Swoft\Aop\Annotation\Mapping\Around;
use Swoft\Aop\Annotation\Mapping\Aspect;
use Swoft\Aop\Annotation\Mapping\Before;
use Swoft\Aop\Annotation\Mapping\PointExecution;
use Swoft\Aop\Point\JoinPoint;
use Swoft\Aop\Point\ProceedingJoinPoint;
use Throwable;

/**
 * @Aspect(order=1)
 *
 * @PointExecution(
 *     include={OrderService::createOrder,UserService::getUserBalance},
 *     exclude={OrderService::generateOrder}
 * )
 */
class DemoAspect
{

    /**
     * 前置通知
     *
     * @Before()
     */
    public function beforeAdvice()
    {

    }

    /**
     * 后置通知
     *
     * @After()
     */
    public function afterAdvice()
    {

    }

    /**
     * 返回通知
     *
     * @AfterReturning()
     *
     * @param JoinPoint $joinPoint
     *
     * @return mixed
     */
    public function afterReturnAdvice(JoinPoint $joinPoint)
    {
        $ret = $joinPoint->getReturn();
        // 返回
        return $ret;
    }

    /**
     * 异常通知
     *
     * @AfterThrowing()
     *
     * @param Throwable $throwable
     */
    public function afterThrowingAdvice(Throwable $throwable)
    {

    }

    /**
     * 环绕通知
     *
     * @Around()
     *
     * @param ProceedingJoinPoint $proceedingJoinPoint
     *
     * @return mixed
     * @throws Throwable
     */
    public function aroundAdvice(ProceedingJoinPoint $proceedingJoinPoint)
    {
        // 前置通知
        $ret = $proceedingJoinPoint->proceed();
        // 后置通知
        return $ret;
    }
}
?>
@Before：前置通知。在目标方法之前执行
@After：后置通知。在目标方法之后执行
@AfterReturing：返回通知
@AfterThrowing：异常通知。目标方法异常时执行
@Around：环绕通知。等同于前置通知加上后置通知，在目标方法之前及之后执行
--
5、业务示例
为了更好的理解，我们使用前置、后置通知实现一个用于计算代码执行时长的例子。
(1)、控制器
///1/ 在控制器中测试更为直观
<?php declare(strict_types=1);

namespace App\Http\Controller;

use Swoft\Http\Server\Annotation\Mapping\Controller;
use Swoft\Http\Server\Annotation\Mapping\RequestMapping;

/**
 * @Controller(prefix="test")
 */
class TestRunTimeController
{

    /**
     * 闭包递归，计算阶乘
     *
     * @RequestMapping(route="factorial/{number}")
     *
     * @param int $number
     *
     * @return array
     */
    public function factorial(int $number): array
    {
        $factorial = function ($arg) use (&$factorial) {
            if ($arg == 1) {
                return $arg;
            }
            return $arg * $factorial($arg - 1);
        };
        return [$factorial($number)];
    }

    /**
     * 计算 1-1000 和，最后休眠 1s
     *
     * @RequestMapping(route="sum")
     */
    public function sumAndSleep(): array
    {
        $sum = 0;
        for ($i = 1; $i <= 1000; $i++) {
            $sum = $sum + $i;
        }
        sleep(1);
        return [$sum];
    }
}
?>
//
//// 启动 HTTP 服务后，我们可以通过访问下方两个地址执行代码
http://localhost:18306/test/factorial/100
http://localhost:18306/test/sum
(2)、切面类
前文已强调，通过 AOP 我们可以在不侵入原有代码的情况下实现额外的操作。请看示例。
<?php declare(strict_types=1);

namespace App\Aspect;

use App\Http\Controller\TestRunTimeController;
use Swoft\Aop\Annotation\Mapping\After;
use Swoft\Aop\Annotation\Mapping\Aspect;
use Swoft\Aop\Annotation\Mapping\Before;
use Swoft\Aop\Annotation\Mapping\PointBean;
use Swoft\Aop\Point\JoinPoint;

/**
 * @Aspect(order=1)
 *
 * @PointBean(include={TestRunTimeController::class})
 */
class CalculateRunTimeAspect {

    /** @var float 执行开始 */
    private $time_begin;

    /**
     * 前置通知
     *
     * @Before()
     */
    public function beforeAdvice()
    {
        // 起点时间
        $this->time_begin = microtime(true);
    }

    /**
     * 后置通知
     *
     * @After()
     *
     * @param JoinPoint $joinPoint
     */
    public function afterAdvice(JoinPoint $joinPoint)
    {
        /** @var float 执行结束 */
        $timeFinish = microtime(true);
        $method = $joinPoint->getMethod();
        $runtime = round(($timeFinish - $this->time_begin) * 1000, 3);
        echo "{$method} 方法，本次执行时间为: {$runtime}ms \n";
    }
}
?>
//
//// 编写完成后重启 HTTP 服务，然后再次访问
http://localhost:18306/test/factorial/100
http://localhost:18306/test/sum
//
//// 得到结果后返回控制台查看执行时间
factorial 方法，本次执行时间为: 0.107ms
sumAndSleep 方法，本次执行时间为: 1000.319ms
--
6、通知执行顺序
前文已提到，多个切面按照 order 属性值进行优先级划分，数字越小优先执行。而在一个切面中的多个通知同样也按照顺序执行。
(1)、单切面
///1/ 正常顺序
( 图 https://www.swoft.org/img/singular-aspect-normal.jpg )
AOP --1--> @Around --2--> @Before --3--> Method --4--> @Around --5--> @After --6--> @AfterReturning
<1>、@Around 环绕通知 前 置部分
<2>、@Before 前置通知
<3>、目标对象方法
<4>、@Around 环绕通知 后 置部分
<5>、@After 后置通知
<6>、@AfterReturn 返回通知
//
///2/ 异常顺序
( 图 https://www.swoft.org/img/singular-aspect-exception.jpg )
AOP --1--> @Around --2--> @Before --3--> Method --4--> @Around --5--> @After --6--> @AfterThrowing
<1>、@Around 环绕通知 前 置部分
<2>、@Before 前置通知
<3>、目标对象方法
<4>、@Around 环绕通知 后 置部分
<5>、@After 后置通知
<6>、@AfterThrowing 返回通知
(2)、多切面
( 图 https://www.swoft.org/img/multiple-aspects.jpg )
//// 以正常情况为例
<1>、切面 1 @Around 环绕通知 前置部分
<2>、切面 1 @Before 前置通知
<3>、切面 2 @Around 环绕通知 前置部分
<4>、切面 2 @Before 前置通知
<5>、目标对象方法
<6>、切面 2 @Around 环绕通知 后置部分
<7>、切面 2 @After 后置通知
<8>、切面 2 @AfterReturn 返回通知
<9>、切面 1 @Around 环绕通知 后置通知
<10>、切面 1 @After 后置通知
<11 >、切面 1 @AfterReturn 返回通知
--
7、注意事项
AOP 仅拦截 public 及 protected 修饰的方法，不会拦截 private 方法。
此外，在 Swoft AOP 中，如果某个方法内调用了另一个 被织入 的方法时，AOP 也会向该方法织入通知。例如我们定义了一个类 A，它有两个 public 方法 func1 和 func2，然后我们定义一个切面，使用 @PointBean(include={A::class}) 注解将 A 类（所有方法）进行织入，示例代码。
//
//// 定义了一个类 A，它有两个 public 方法 func1 和 func2，然后我们定义一个切面，使用 @PointBean(include={A::class}) 注解将 A 类（所有方法）进行织入
<?php
class A
{
    function func1()
    {
        echo "func1 \n";
    }

    function func2()
    {
        $this->func1();
        echo "func2 \n";
    }
}
?>
当我们执行 func2 时，我们的切面会被执行 两次，两次执行的顺序相同。切面会先对 func2 织入通知，其次对 func1 织入通知。
--
--
四、事件







第六卷
()、
--
--
--